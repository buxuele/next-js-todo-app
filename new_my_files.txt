
å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\app.py
å†…å®¹:
from flask import Flask, render_template
from models import db, DateAlias
from routes import todo_bp, ensure_today_todo_file
from config import Config

app = Flask(__name__)
app.config.from_object(Config)

# ä¿®æ”¹æ•°æ®åº“URIä¸ºæ–°æ•°æ®åº“
import os
instance_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance')
os.makedirs(instance_dir, exist_ok=True)  # ç¡®ä¿instanceç›®å½•å­˜åœ¨
db_path = os.path.join(instance_dir, 'todos_new.db')
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'

db.init_app(app)

# æ³¨å†Œ API è“å›¾
app.register_blueprint(todo_bp)

# ä¸»é¡µè·¯ç”±åªè´Ÿè´£æä¾› HTML é¡µé¢
# JavaScript ä¼šé€šè¿‡ API /api/todos è·å–æ•°æ®
@app.route('/')
def index():
    return render_template('index.html')

if __name__ == '__main__':
     
    # è‡ªåŠ¨åˆ›å»ºæµ‹è¯•æ•°æ®ï¼ˆæœ€è¿‘ä¸€å‘¨çš„7ä¸ªè¡¨ï¼‰
    from create_test_data import create_test_data

    # åˆ›å»ºæ•°æ®åº“è¡¨
    with app.app_context():
        db.create_all()
        print("æ•°æ®åº“è¡¨å·²åˆ›å»º")
    
    # ç¡®ä¿ä»Šå¤©çš„todoæ–‡ä»¶å­˜åœ¨
    ensure_today_todo_file()
   
    # create_test_data()

    # ä¸´æ—¶è°ƒè¯•ï¼Œç«¯å£æ˜¯ 5990
    # å¼€æœºè¿è¡Œï¼Œç«¯å£æ˜¯ 5995
    app.run(debug=True, port=5990)



å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\app.pyw
å†…å®¹:
from flask import Flask, render_template
from models import db, DateAlias
from routes import todo_bp, ensure_today_todo_file
from config import Config

app = Flask(__name__)
app.config.from_object(Config)

# ä¿®æ”¹æ•°æ®åº“URIä¸ºæ–°æ•°æ®åº“
import os
instance_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance')
os.makedirs(instance_dir, exist_ok=True)  # ç¡®ä¿instanceç›®å½•å­˜åœ¨
db_path = os.path.join(instance_dir, 'todos_new.db')
app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{db_path}'

db.init_app(app)

# æ³¨å†Œ API è“å›¾
app.register_blueprint(todo_bp)

# ä¸»é¡µè·¯ç”±åªè´Ÿè´£æä¾› HTML é¡µé¢
# JavaScript ä¼šé€šè¿‡ API /api/todos è·å–æ•°æ®
@app.route('/')
def index():
    return render_template('index.html')

if __name__ == '__main__':
     
    # è‡ªåŠ¨åˆ›å»ºæµ‹è¯•æ•°æ®ï¼ˆæœ€è¿‘ä¸€å‘¨çš„7ä¸ªè¡¨ï¼‰
    from create_test_data import create_test_data

    # åˆ›å»ºæ•°æ®åº“è¡¨
    with app.app_context():
        db.create_all()
        print("æ•°æ®åº“è¡¨å·²åˆ›å»º")
    
    # ç¡®ä¿ä»Šå¤©çš„todoæ–‡ä»¶å­˜åœ¨
    ensure_today_todo_file()
   
    # create_test_data()

    # ä¸´æ—¶è°ƒè¯•ï¼Œç«¯å£æ˜¯ 5990
    # å¼€æœºè¿è¡Œï¼Œç«¯å£æ˜¯ 5995
    app.run(debug=True, port=5995)



    

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\config.py
å†…å®¹:
import os
from datetime import timedelta

# è·å–é¡¹ç›®æ ¹ç›®å½•
basedir = os.path.abspath(os.path.dirname(__file__))

class Config:
    """åŸºç¡€é…ç½®"""
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key-change-in-production'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    
    # åº”ç”¨é…ç½®
    APP_NAME = "Flask Todo App"
    APP_VERSION = "1.0.0"
    
    # æ•°æ®åº“é…ç½®
    DB_POOL_SIZE = 10
    DB_TIMEOUT = 30
    
    # å®‰å…¨é…ç½®
    WTF_CSRF_ENABLED = True
    WTF_CSRF_TIME_LIMIT = timedelta(hours=1)
    
    # æ—¥å¿—é…ç½®
    LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')
    LOG_FILE = os.environ.get('LOG_FILE', 'logs/app.log')

class DevelopmentConfig(Config):
    """å¼€å‘ç¯å¢ƒé…ç½®"""
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'instance', 'todos_dev.db')
    
    # å¼€å‘ç¯å¢ƒç‰¹å®šé…ç½®
    TESTING = False
    WTF_CSRF_ENABLED = False  # å¼€å‘æ—¶ç¦ç”¨CSRF

class ProductionConfig(Config):
    """ç”Ÿäº§ç¯å¢ƒé…ç½®"""
    DEBUG = False
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'instance', 'todos.db')
    
    # ç”Ÿäº§ç¯å¢ƒç‰¹å®šé…ç½®
    TESTING = False
    WTF_CSRF_ENABLED = True

class TestingConfig(Config):
    """æµ‹è¯•ç¯å¢ƒé…ç½®"""
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
    WTF_CSRF_ENABLED = False

# é…ç½®æ˜ å°„
config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'testing': TestingConfig,
    'default': DevelopmentConfig
}



å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\create_test_data.py
å†…å®¹:
#!/usr/bin/env python3
"""
åˆ›å»ºæµ‹è¯•æ•°æ® - è‡ªåŠ¨ç”Ÿæˆæœ€è¿‘ä¸€å‘¨çš„7ä¸ªè¡¨å’Œç¤ºä¾‹ä»»åŠ¡
"""


from datetime import datetime, timedelta
from models import DailyTodoManager
import random

def create_test_data():
    """åˆ›å»ºæœ€è¿‘ä¸€å‘¨çš„æµ‹è¯•æ•°æ®"""
    manager = DailyTodoManager()
    
    # ç¤ºä¾‹ä»»åŠ¡å†…å®¹
    sample_tasks = [
        "å®Œæˆé¡¹ç›®æ–‡æ¡£",
        "å¼€ä¼šè®¨è®ºéœ€æ±‚",
        "ä»£ç å®¡æŸ¥",
        "ä¿®å¤bug #123",
        "æ›´æ–°ç”¨æˆ·æ‰‹å†Œ",
        "æµ‹è¯•æ–°åŠŸèƒ½",
        "ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢",
        "å›å¤å®¢æˆ·é‚®ä»¶",
        "å‡†å¤‡æ¼”ç¤ºæ–‡ç¨¿",
        "å­¦ä¹ æ–°æŠ€æœ¯",
        "æ•´ç†ä»£ç ä»“åº“",
        "å†™å•å…ƒæµ‹è¯•",
        "éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ",
        "åˆ†ææ€§èƒ½é—®é¢˜",
        "æ›´æ–°ä¾èµ–åŒ…"
    ]
    
    print("æ­£åœ¨åˆ›å»ºæœ€è¿‘ä¸€å‘¨çš„æµ‹è¯•æ•°æ®...")
    
    # åˆ›å»ºæœ€è¿‘7å¤©çš„æ•°æ®ï¼ˆåŒ…æ‹¬ä»Šå¤©ï¼‰
    for i in range(7):
        # è®¡ç®—æ—¥æœŸï¼ˆä»6å¤©å‰åˆ°ä»Šå¤©ï¼‰
        date = datetime.now() - timedelta(days=6-i)
        date_str = date.strftime('%Y-%m-%d')
        
        print(f"åˆ›å»º {date_str} çš„æµ‹è¯•æ•°æ®...")
        
        # ä¸ºæ¯ä¸ªæ—¥æœŸéšæœºåˆ›å»º2-5ä¸ªä»»åŠ¡
        num_tasks = random.randint(2, 5)
        selected_tasks = random.sample(sample_tasks, num_tasks)
        
        for task_content in selected_tasks:
            task_id = manager.add_todo(date_str, task_content)
            
            # éšæœºè®¾ç½®ä¸€äº›ä»»åŠ¡ä¸ºå·²å®Œæˆï¼ˆ30%çš„æ¦‚ç‡ï¼‰
            if random.random() < 0.3:
                manager.update_todo(date_str, task_id, completed=True)
        
        print(f"  âœ“ åˆ›å»ºäº† {num_tasks} ä¸ªä»»åŠ¡")
    
    print("\næµ‹è¯•æ•°æ®åˆ›å»ºå®Œæˆï¼")
    print("ç°åœ¨ä½ å¯ä»¥æµ‹è¯•åˆ é™¤åŠŸèƒ½äº†ã€‚")
    
    # æ˜¾ç¤ºåˆ›å»ºçš„æ•°æ®ç»Ÿè®¡
    counts = manager.get_todo_counts()
    print("\nå½“å‰æ•°æ®ç»Ÿè®¡:")
    for date_str, count in sorted(counts.items(), reverse=True):
        date_obj = datetime.strptime(date_str, '%Y-%m-%d')
        display_date = date_obj.strftime('%mæœˆ%dæ—¥')
        print(f"  {display_date}: {count} ä¸ªä»»åŠ¡")

if __name__ == "__main__":
    create_test_data()

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\init_db.py
å†…å®¹:
from app import app, db
from models import DateAlias, DailyTodoManager
from datetime import datetime, timedelta
import logging

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def init_database():
    """åˆå§‹åŒ–æ•°æ®åº“"""
    try:
        with app.app_context():
            # åˆ›å»ºåŸºç¡€è¡¨ï¼ˆDateAliasè¡¨ï¼‰
            db.create_all()
            
            # åˆå§‹åŒ–todoç®¡ç†å™¨
            todo_manager = DailyTodoManager()
            
            # æ·»åŠ ç¤ºä¾‹æ•°æ®
            add_sample_data(todo_manager)
            
            print('æ•°æ®åº“åˆå§‹åŒ–å®Œæˆï¼Œå·²æ·»åŠ ç¤ºä¾‹æ•°æ®')
            
    except Exception as e:
        logger.error(f"æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: {str(e)}")
        raise

def add_sample_data(todo_manager):
    """æ·»åŠ ç¤ºä¾‹æ•°æ®"""
    try:
        today = datetime.now().strftime('%Y-%m-%d')
        yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        
        # ä»Šå¤©çš„ä»»åŠ¡
        today_todos = [
            "å®Œæˆé¡¹ç›®æ–‡æ¡£",
            "å¼€ä¼šè®¨è®ºéœ€æ±‚", 
            "ä»£ç å®¡æŸ¥",
            "æ›´æ–°æ•°æ®åº“è®¾è®¡",
            "æµ‹è¯•æ–°åŠŸèƒ½"
        ]
        
        # ä¸ºä»Šå¤©åˆ›å»ºè¡¨å¹¶æ·»åŠ ä»»åŠ¡
        for i, content in enumerate(today_todos):
            todo_id = todo_manager.add_todo(today, content)
            # ç¬¬äºŒä¸ªä»»åŠ¡æ ‡è®°ä¸ºå·²å®Œæˆ
            if i == 1:
                todo_manager.update_todo(today, todo_id, completed=True)
        
        # æ˜¨å¤©çš„ä»»åŠ¡ï¼ˆå·²å®Œæˆï¼‰
        yesterday_todos = [
            "å‡†å¤‡ä¼šè®®ææ–™",
            "å›å¤é‚®ä»¶",
            "æ•´ç†ä»£ç "
        ]
        
        # ä¸ºæ˜¨å¤©åˆ›å»ºè¡¨å¹¶æ·»åŠ ä»»åŠ¡
        for content in yesterday_todos:
            todo_id = todo_manager.add_todo(yesterday, content)
            # æ‰€æœ‰æ˜¨å¤©çš„ä»»åŠ¡éƒ½æ ‡è®°ä¸ºå·²å®Œæˆ
            todo_manager.update_todo(yesterday, todo_id, completed=True)
        
        # æ·»åŠ æ—¥æœŸåˆ«åç¤ºä¾‹
        with app.app_context():
            date_alias = DateAlias(
                date=yesterday,
                alias="æ˜¨æ—¥å·¥ä½œ"
            )
            db.session.add(date_alias)
            db.session.commit()
        
        logger.info(f"æˆåŠŸæ·»åŠ  {len(today_todos)} ä¸ªä»Šæ—¥ä»»åŠ¡å’Œ {len(yesterday_todos)} ä¸ªæ˜¨æ—¥ä»»åŠ¡")
        
    except Exception as e:
        logger.error(f"æ·»åŠ ç¤ºä¾‹æ•°æ®å¤±è´¥: {str(e)}")
        raise

if __name__ == '__main__':
    init_database() 

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\models.py
å†…å®¹:
"""
æ–°çš„æ•°æ®åº“æ¨¡å‹ - æ¯å¤©ä¸€ä¸ªè¡¨çš„è®¾è®¡
"""
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
import sqlite3
import os
import uuid

db = SQLAlchemy()

class TableRegistry(db.Model):
    """è¡¨æ³¨å†Œè¡¨ - è®°å½•æ‰€æœ‰todoè¡¨çš„å…ƒä¿¡æ¯"""
    __tablename__ = 'table_registry'
    
    id = db.Column(db.Integer, primary_key=True)
    table_id = db.Column(db.String(36), nullable=False, unique=True)  # UUID
    display_name = db.Column(db.String(100), nullable=False)  # æ˜¾ç¤ºåç§°
    table_type = db.Column(db.String(20), default='daily')  # è¡¨ç±»å‹: daily, copy
    source_date = db.Column(db.String(10), nullable=True)  # åŸå§‹æ—¥æœŸï¼ˆå¦‚æœæ˜¯æ—¥æœŸè¡¨ï¼‰
    source_table_id = db.Column(db.String(36), nullable=True)  # å¤åˆ¶æ¥æºè¡¨ID
    created_at = db.Column(db.DateTime, default=datetime.now)
    is_active = db.Column(db.Boolean, default=True)  # æ˜¯å¦æ´»è·ƒ

    def to_dict(self):
        return {
            'id': self.id,
            'table_id': self.table_id,
            'display_name': self.display_name,
            'table_type': self.table_type,
            'source_date': self.source_date,
            'source_table_id': self.source_table_id,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'is_active': self.is_active
        }

class DateAlias(db.Model):
    """æ—¥æœŸåˆ«åè¡¨ - å…¼å®¹æ—§ç³»ç»Ÿ"""
    __tablename__ = 'date_aliases'
    
    id = db.Column(db.Integer, primary_key=True)
    date = db.Column(db.String(10), nullable=False, unique=True)  # æ ¼å¼: YYYY-MM-DD
    alias = db.Column(db.String(50), nullable=False)  # è‡ªå®šä¹‰åˆ«å
    created_at = db.Column(db.DateTime, default=datetime.now)

    def to_dict(self):
        return {
            'id': self.id,
            'date': self.date,
            'alias': self.alias,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }

class DailyTodoManager:
    """æ¯æ—¥Todoç®¡ç†å™¨ - å¤„ç†åŠ¨æ€è¡¨æ“ä½œï¼Œæ”¯æŒUUIDè¡¨å"""
    
    def __init__(self, db_path='instance/todos_new.db'):
        self.db_path = db_path
        self.ensure_db_exists()
    
    def ensure_db_exists(self):
        """ç¡®ä¿æ•°æ®åº“æ–‡ä»¶å­˜åœ¨"""
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
    
    def get_table_name_by_id(self, table_id):
        """æ ¹æ®è¡¨IDç”Ÿæˆå®é™…çš„è¡¨å"""
        return f"todo_{table_id.replace('-', '_')}"
    
    def get_table_name(self, date_str):
        """å…¼å®¹æ—§ç³»ç»Ÿï¼šæ ¹æ®æ—¥æœŸæˆ–å”¯ä¸€æ ‡è¯†ç¬¦ç”Ÿæˆè¡¨å"""
        # å¤„ç†æ–°çš„å¤åˆ¶æ ‡è¯†ç¬¦æ ¼å¼ï¼šcopy-YYYYMMDD-timestamp
        # ä»¥åŠä¼ ç»Ÿæ—¥æœŸæ ¼å¼ï¼šYYYY-MM-DD
        return f"todo_{date_str.replace('-', '_')}"
    
    def create_table_for_date(self, date_str):
        """ä¸ºæŒ‡å®šæ—¥æœŸåˆ›å»ºè¡¨ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œå…¼å®¹æ—§ç³»ç»Ÿå’Œæ–°çš„å¤åˆ¶æ ‡è¯†ç¬¦ï¼‰"""
        table_name = self.get_table_name(date_str)
        self._create_physical_table(table_name)
        return table_name
    
    def create_copy_table(self, source_table_id, display_name):
        """åˆ›å»ºå¤åˆ¶è¡¨"""
        from flask import current_app
        with current_app.app_context():
            # ç”Ÿæˆæ–°çš„UUID
            new_table_id = str(uuid.uuid4())
            
            # åˆ›å»ºæ³¨å†Œè®°å½•
            registry_entry = TableRegistry(
                table_id=new_table_id,
                display_name=display_name,
                table_type='copy',
                source_table_id=source_table_id
            )
            
            db.session.add(registry_entry)
            db.session.commit()
            
            # åˆ›å»ºå®é™…çš„æ•°æ®åº“è¡¨
            new_table_name = self.get_table_name_by_id(new_table_id)
            self._create_physical_table(new_table_name)
            
            return new_table_id, new_table_name
    
    def _create_physical_table(self, table_name):
        """åˆ›å»ºç‰©ç†æ•°æ®åº“è¡¨"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        create_sql = f"""
        CREATE TABLE IF NOT EXISTS {table_name} (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            content TEXT NOT NULL,
            completed BOOLEAN DEFAULT 0,
            order_num INTEGER DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            completed_at DATETIME NULL
        )
        """
        
        cursor.execute(create_sql)
        conn.commit()
        conn.close()
    
    def format_date_for_display(self, date_str):
        """æ ¼å¼åŒ–æ—¥æœŸç”¨äºæ˜¾ç¤º"""
        try:
            date_obj = datetime.strptime(date_str, '%Y-%m-%d')
            return date_obj.strftime('%mæœˆ%dæ—¥')
        except:
            return date_str
    
    def table_exists_by_id(self, table_id):
        """æ£€æŸ¥æŒ‡å®šè¡¨IDçš„è¡¨æ˜¯å¦å­˜åœ¨"""
        table_name = self.get_table_name_by_id(table_id)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name=?
        """, (table_name,))
        
        exists = cursor.fetchone() is not None
        conn.close()
        
        return exists
    
    def table_exists(self, date_str):
        """æ£€æŸ¥æŒ‡å®šæ—¥æœŸçš„è¡¨æ˜¯å¦å­˜åœ¨ï¼ˆå…¼å®¹æ—§ç³»ç»Ÿï¼‰"""
        table_name = self.get_table_name(date_str)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name=?
        """, (table_name,))
        
        exists = cursor.fetchone() is not None
        conn.close()
        
        return exists
    
    def get_todos_by_table_id(self, table_id):
        """æ ¹æ®è¡¨IDè·å–todos"""
        if not self.table_exists_by_id(table_id):
            return []
        
        table_name = self.get_table_name_by_id(table_id)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute(f"""
        SELECT id, content, completed, order_num, created_at, completed_at
        FROM {table_name}
        ORDER BY order_num, id
        """)
        
        rows = cursor.fetchall()
        conn.close()
        
        todos = []
        for row in rows:
            todos.append({
                'id': row[0],
                'content': row[1],
                'completed': bool(row[2]),
                'order': row[3],
                'table_id': table_id,
                'created_at': row[4],
                'completed_at': row[5]
            })
        
        return todos
    
    def get_todos_for_date(self, date_str):
        """è·å–æŒ‡å®šæ—¥æœŸçš„æ‰€æœ‰todosï¼ˆå…¼å®¹æ—§ç³»ç»Ÿï¼‰"""
        if not self.table_exists(date_str):
            return []
        
        table_name = self.get_table_name(date_str)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute(f"""
        SELECT id, content, completed, order_num, created_at, completed_at
        FROM {table_name}
        ORDER BY order_num, id
        """)
        
        rows = cursor.fetchall()
        conn.close()
        
        todos = []
        for row in rows:
            todos.append({
                'id': row[0],
                'content': row[1],
                'completed': bool(row[2]),
                'order': row[3],
                'date': date_str,
                'created_at': row[4],
                'completed_at': row[5]
            })
        
        return todos
    
    def add_todo_by_table_id(self, table_id, content, order_num=None):
        """æ ¹æ®è¡¨IDæ·»åŠ æ–°çš„todo"""
        if not self.table_exists_by_id(table_id):
            return None
        
        table_name = self.get_table_name_by_id(table_id)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # å¦‚æœæ²¡æœ‰æŒ‡å®šorderï¼Œè·å–æœ€å¤§å€¼+1
        if order_num is None:
            cursor.execute(f"SELECT MAX(order_num) FROM {table_name}")
            max_order = cursor.fetchone()[0] or 0
            order_num = max_order + 1
        
        cursor.execute(f"""
        INSERT INTO {table_name} (content, completed, order_num, created_at)
        VALUES (?, ?, ?, ?)
        """, (content, 0, order_num, datetime.now().isoformat()))
        
        todo_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return todo_id

    def add_todo(self, date_str, content, order_num=None):
        """æ·»åŠ æ–°çš„todoï¼ˆå…¼å®¹æ—§ç³»ç»Ÿå’Œæ–°çš„å¤åˆ¶æ ‡è¯†ç¬¦ï¼‰"""
        # å¯¹äºå¤åˆ¶æ ‡è¯†ç¬¦ï¼Œç›´æ¥åˆ›å»ºè¡¨ï¼Œä¸éœ€è¦æ³¨å†Œè¡¨é€»è¾‘
        if date_str.startswith('copy-'):
            table_name = self.get_table_name(date_str)
            self._create_physical_table(table_name)
        else:
            # ç¡®ä¿è¡¨å­˜åœ¨ï¼ˆä¼ ç»Ÿæ—¥æœŸæ ¼å¼ï¼‰
            table_name = self.create_table_for_date(date_str)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # å¦‚æœæ²¡æœ‰æŒ‡å®šorderï¼Œè·å–æœ€å¤§å€¼+1
        if order_num is None:
            cursor.execute(f"SELECT MAX(order_num) FROM {table_name}")
            max_order = cursor.fetchone()[0] or 0
            order_num = max_order + 1
        
        cursor.execute(f"""
        INSERT INTO {table_name} (content, completed, order_num, created_at)
        VALUES (?, ?, ?, ?)
        """, (content, 0, order_num, datetime.now().isoformat()))
        
        todo_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return todo_id
    
    def update_todo(self, date_str, todo_id, **kwargs):
        """æ›´æ–°todoï¼ˆæ”¯æŒæ—¥æœŸå’Œå¤åˆ¶æ ‡è¯†ç¬¦ï¼‰"""
        if not self.table_exists(date_str):
            return False
        
        table_name = self.get_table_name(date_str)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # æ„å»ºæ›´æ–°è¯­å¥
        update_fields = []
        values = []
        
        if 'content' in kwargs:
            update_fields.append('content = ?')
            values.append(kwargs['content'])
        
        if 'completed' in kwargs:
            update_fields.append('completed = ?')
            values.append(kwargs['completed'])
            
            # å¦‚æœè®¾ç½®å®ŒæˆçŠ¶æ€ï¼ŒåŒæ—¶æ›´æ–°å®Œæˆæ—¶é—´
            if kwargs['completed']:
                update_fields.append('completed_at = ?')
                values.append(datetime.now().isoformat())
            else:
                update_fields.append('completed_at = ?')
                values.append(None)
        
        if 'order_num' in kwargs:
            update_fields.append('order_num = ?')
            values.append(kwargs['order_num'])
        
        if not update_fields:
            conn.close()
            return False
        
        values.append(todo_id)
        
        cursor.execute(f"""
        UPDATE {table_name}
        SET {', '.join(update_fields)}
        WHERE id = ?
        """, values)
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    def delete_todo(self, date_str, todo_id):
        """åˆ é™¤todo"""
        if not self.table_exists(date_str):
            return False
        
        table_name = self.get_table_name(date_str)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute(f"DELETE FROM {table_name} WHERE id = ?", (todo_id,))
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    def delete_all_todos_for_date(self, date_str):
        """åˆ é™¤æŒ‡å®šæ—¥æœŸçš„æ‰€æœ‰todoså¹¶åˆ é™¤è¡¨"""
        if not self.table_exists(date_str):
            return 0
        
        table_name = self.get_table_name(date_str)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # å…ˆè·å–ä»»åŠ¡æ•°é‡
        cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
        count = cursor.fetchone()[0]
        
        # åˆ é™¤æ•´ä¸ªè¡¨ï¼Œè€Œä¸æ˜¯åªåˆ é™¤æ•°æ®
        cursor.execute(f"DROP TABLE IF EXISTS {table_name}")
        conn.commit()
        conn.close()
        
        return count
    
    def get_available_dates(self):
        """è·å–æ‰€æœ‰æœ‰æ•°æ®çš„æ—¥æœŸå’Œæ ‡è¯†ç¬¦"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name LIKE 'todo_%'
        ORDER BY name DESC
        """)
        
        tables = cursor.fetchall()
        conn.close()
        
        dates = []
        for table in tables:
            table_name = table[0]
            # ä»è¡¨åæ¢å¤åŸå§‹æ ‡è¯†ç¬¦
            identifier = table_name.replace('todo_', '').replace('_', '-')
            dates.append(identifier)
        
        return dates
    
    def get_todo_counts(self):
        """è·å–æ¯ä¸ªæ—¥æœŸçš„todoæ•°é‡"""
        dates = self.get_available_dates()
        counts = {}
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        for date_str in dates:
            table_name = self.get_table_name(date_str)
            cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
            counts[date_str] = cursor.fetchone()[0]
        
        conn.close()
        return counts

# å…¨å±€å®ä¾‹
todo_manager = DailyTodoManager()

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\requirements.txt
å†…å®¹:
blinker==1.9.0
click==8.2.1
colorama==0.4.6
dominate==2.9.1
Flask==3.1.1
Flask-Bootstrap==3.3.7.1
Flask-SQLAlchemy==3.1.1
greenlet==3.2.3
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
SQLAlchemy==2.0.41
typing_extensions==4.14.1
visitor==0.1.3
Werkzeug==3.1.3


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\routes.py
å†…å®¹:
"""
æ–°çš„è·¯ç”±æ–‡ä»¶ - æ”¯æŒæ¯æ—¥ä¸€è¡¨æ¶æ„
"""
from flask import Blueprint, request, jsonify, send_file
from models import DailyTodoManager, DateAlias, db
from datetime import datetime
import os

# ä½¿ç”¨ 'api' ä½œä¸ºè“å›¾åç§°ï¼Œå¹¶æ·»åŠ  URL å‰ç¼€
todo_bp = Blueprint('api', __name__, url_prefix='/api')

# å…¨å±€todoç®¡ç†å™¨å®ä¾‹
todo_manager = DailyTodoManager()

def _is_valid_date_format(date_str):
    """éªŒè¯æ—¥æœŸæ ¼å¼æ˜¯å¦ä¸ºYYYY-MM-DD"""
    try:
        datetime.strptime(date_str, '%Y-%m-%d')
        return True
    except ValueError:
        return False

def ensure_today_todo_file():
    """ç¡®ä¿ä»Šå¤©çš„todoæ–‡ä»¶å’Œæ•°æ®åº“è¡¨å­˜åœ¨"""
    today = datetime.now().strftime('%Y-%m-%d')
    date_obj = datetime.strptime(today, '%Y-%m-%d')
    formatted_date = date_obj.strftime('%m.%d')
    
    # 1. ç¡®ä¿ä»Šå¤©çš„æ•°æ®åº“è¡¨å­˜åœ¨
    table_name = todo_manager.create_table_for_date(today)
    print(f"å·²ç¡®ä¿ä»Šæ—¥æ•°æ®åº“è¡¨å­˜åœ¨: {table_name}")
    
    # 2. åˆ›å»ºdocsæ–‡ä»¶å¤¹
    docs_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'docs')
    if not os.path.exists(docs_dir):
        os.makedirs(docs_dir)
    
    filename = f"{formatted_date}-todo.md"
    filepath = os.path.join(docs_dir, filename)
    
    # 3. å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„todoæ–‡ä»¶
    if not os.path.exists(filepath):
        content = f"# {formatted_date} Todo\n\nä»Šæ—¥æ— ä»»åŠ¡\n\n---\nåˆ›å»ºæ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"å·²åˆ›å»ºä»Šæ—¥Todoæ–‡ä»¶: {filename}")
    else:
        print(f"ä»Šæ—¥Todoæ–‡ä»¶å·²å­˜åœ¨: {filename}")

@todo_bp.route('/todos', methods=['GET'])
def get_todos():
    """è·å–æŒ‡å®šæ—¥æœŸçš„todos"""
    date = request.args.get('date')
    if not date:
        # å¦‚æœæ²¡æœ‰æŒ‡å®šæ—¥æœŸï¼Œè¿”å›ä»Šå¤©çš„todos
        date = datetime.now().strftime('%Y-%m-%d')
    
    todos = todo_manager.get_todos_for_date(date)
    return jsonify(todos)

@todo_bp.route('/todos', methods=['POST'])
def add_todo():
    """æ·»åŠ æ–°çš„todo"""
    data = request.json
    content = data.get('content')
    date = data.get('date') or datetime.now().strftime('%Y-%m-%d')
    
    if not content:
        return jsonify({'error': 'Content is required'}), 400
    
    todo_id = todo_manager.add_todo(date, content)
    
    # è¿”å›æ–°åˆ›å»ºçš„todo
    todos = todo_manager.get_todos_for_date(date)
    new_todo = next((t for t in todos if t['id'] == todo_id), None)
    
    if new_todo:
        return jsonify(new_todo), 201
    else:
        return jsonify({'error': 'Failed to create todo'}), 500

@todo_bp.route('/todos/counts', methods=['GET'])
def get_todo_counts():
    """è·å–æ¯ä¸ªæ—¥æœŸçš„todoæ•°é‡"""
    counts = todo_manager.get_todo_counts()
    return jsonify(counts)

@todo_bp.route('/todos/<int:todo_id>', methods=['GET'])
def get_todo(todo_id):
    """è·å–å•ä¸ªtodo - éœ€è¦æ—¥æœŸå‚æ•°"""
    date = request.args.get('date')
    if not date:
        return jsonify({'error': 'Date parameter is required'}), 400
    
    todos = todo_manager.get_todos_for_date(date)
    todo = next((t for t in todos if t['id'] == todo_id), None)
    
    if todo:
        return jsonify(todo)
    else:
        return jsonify({'error': 'Todo not found'}), 404

@todo_bp.route('/todos/<int:todo_id>', methods=['PUT'])
def update_todo(todo_id):
    """æ›´æ–°todo"""
    data = request.json
    date = data.get('date')
    
    if not date:
        return jsonify({'error': 'Date parameter is required'}), 400
    
    update_data = {}
    if 'content' in data:
        update_data['content'] = data['content']
    if 'completed' in data:
        update_data['completed'] = data['completed']
    if 'order' in data:
        update_data['order_num'] = data['order']
    
    success = todo_manager.update_todo(date, todo_id, **update_data)
    
    if success:
        # è¿”å›æ›´æ–°åçš„todo
        todos = todo_manager.get_todos_for_date(date)
        updated_todo = next((t for t in todos if t['id'] == todo_id), None)
        return jsonify(updated_todo)
    else:
        return jsonify({'error': 'Todo not found or update failed'}), 404

@todo_bp.route('/todos/<int:todo_id>', methods=['DELETE'])
def delete_todo(todo_id):
    """åˆ é™¤å•ä¸ªtodo"""
    date = request.args.get('date')
    if not date:
        return jsonify({'error': 'Date parameter is required'}), 400
    
    success = todo_manager.delete_todo(date, todo_id)
    
    if success:
        return '', 204
    else:
        return jsonify({'error': 'Todo not found'}), 404

@todo_bp.route('/todos/<int:todo_id>/copy', methods=['POST'])
def copy_todo(todo_id):
    """å¤åˆ¶todo"""
    date = request.args.get('date')
    if not date:
        return jsonify({'error': 'Date parameter is required'}), 400
    
    # è·å–åŸtodo
    todos = todo_manager.get_todos_for_date(date)
    original_todo = next((t for t in todos if t['id'] == todo_id), None)
    
    if not original_todo:
        return jsonify({'error': 'Todo not found'}), 404
    
    # å¤åˆ¶åˆ°åŒä¸€æ—¥æœŸ
    new_todo_id = todo_manager.add_todo(date, original_todo['content'])
    
    # è¿”å›æ–°åˆ›å»ºçš„todo
    todos = todo_manager.get_todos_for_date(date)
    new_todo = next((t for t in todos if t['id'] == new_todo_id), None)
    
    return jsonify(new_todo), 201

@todo_bp.route('/todos/date/<date>', methods=['DELETE'])
def delete_todos_by_date(date):
    """åˆ é™¤æŒ‡å®šæ—¥æœŸçš„æ‰€æœ‰todos"""
    count = todo_manager.delete_all_todos_for_date(date)
    
    # åŒæ—¶åˆ é™¤è¯¥æ—¥æœŸçš„åˆ«å
    try:
        alias = DateAlias.query.filter_by(date=date).first()
        if alias:
            db.session.delete(alias)
            db.session.commit()
    except Exception as e:
        # åˆ«ååˆ é™¤å¤±è´¥ä¸å½±å“ä¸»è¦åŠŸèƒ½
        print(f"åˆ é™¤æ—¥æœŸåˆ«åå¤±è´¥: {e}")
    
    return jsonify({'message': f'å·²åˆ é™¤ {count} ä¸ªä»»åŠ¡', 'count': count})

@todo_bp.route('/todos/copy-date', methods=['POST'])
def copy_date_todos():
    """å¤åˆ¶æ•´ä¸ªæ—¥æœŸçš„todosåˆ°æ–°æ—¥æœŸ"""
    data = request.json
    source_date = data.get('source_date')
    target_date = data.get('target_date')
    
    if not source_date or not target_date:
        return jsonify({'error': 'Source date and target date are required'}), 400
    
    # è·å–æºæ—¥æœŸçš„æ‰€æœ‰todos
    source_todos = todo_manager.get_todos_for_date(source_date)
    
    # å³ä½¿æ²¡æœ‰ä»»åŠ¡ä¹Ÿè¦åˆ›å»ºç›®æ ‡æ—¥æœŸçš„è¡¨
    copied_count = 0
    if source_todos:
        # å¤åˆ¶åˆ°ç›®æ ‡æ—¥æœŸ
        for todo in source_todos:
            todo_manager.add_todo(target_date, todo['content'])
            copied_count += 1
    else:
        # å³ä½¿æºæ—¥æœŸæ²¡æœ‰ä»»åŠ¡ï¼Œä¹Ÿè¦ç¡®ä¿ç›®æ ‡æ—¥æœŸçš„è¡¨å­˜åœ¨
        # é€šè¿‡åˆ›å»ºè¡¨æ¥å®ç°"å¤åˆ¶ç©ºåˆ—è¡¨"
        todo_manager.create_table_for_date(target_date)
    
    return jsonify({
        'message': f'å·²å¤åˆ¶ {copied_count} ä¸ªä»»åŠ¡',
        'count': copied_count
    })

@todo_bp.route('/date-aliases', methods=['GET'])
def get_date_aliases():
    """è·å–æ‰€æœ‰æ—¥æœŸåˆ«å"""
    try:
        aliases = DateAlias.query.all()
        return jsonify({alias.date: alias.alias for alias in aliases})
    except Exception as e:
        print(f"è·å–æ—¥æœŸåˆ«åå¤±è´¥: {e}")
        return jsonify({})

@todo_bp.route('/date-aliases', methods=['POST'])
def set_date_alias():
    """è®¾ç½®æˆ–æ›´æ–°æ—¥æœŸåˆ«å"""
    data = request.json
    date = data.get('date')
    alias = data.get('alias')
    
    if not date or not alias:
        return jsonify({'error': 'Date and alias are required'}), 400
    
    # éªŒè¯æ—¥æœŸæ ¼å¼ - æ”¯æŒæ ‡å‡†æ—¥æœŸæ ¼å¼å’Œå¤åˆ¶è¡¨çš„å”¯ä¸€æ ‡è¯†ç¬¦æ ¼å¼
    if not (date.startswith('copy-') or _is_valid_date_format(date)):
        return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD or copy-* format'}), 400
    
    try:
        # æŸ¥æ‰¾ç°æœ‰åˆ«åæˆ–åˆ›å»ºæ–°çš„
        existing_alias = DateAlias.query.filter_by(date=date).first()
        if existing_alias:
            existing_alias.alias = alias
        else:
            new_alias = DateAlias(date=date, alias=alias)
            db.session.add(new_alias)
        
        db.session.commit()
        return jsonify({'message': 'Date alias updated successfully'})
    except Exception as e:
        print(f"è®¾ç½®æ—¥æœŸåˆ«åå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@todo_bp.route('/date-aliases/<date>', methods=['DELETE'])
def delete_date_alias(date):
    """åˆ é™¤æ—¥æœŸåˆ«å"""
    try:
        alias = DateAlias.query.filter_by(date=date).first()
        if alias:
            db.session.delete(alias)
            db.session.commit()
            return jsonify({'message': 'Date alias deleted successfully'})
        else:
            return jsonify({'error': 'Date alias not found'}), 404
    except Exception as e:
        print(f"åˆ é™¤æ—¥æœŸåˆ«åå¤±è´¥: {e}")
        return jsonify({'error': str(e)}), 500

@todo_bp.route('/todos/export/<date>', methods=['GET'])
def export_todo(date):
    """å¯¼å‡ºæŒ‡å®šæ—¥æœŸçš„todosä¸ºmarkdownæ–‡ä»¶"""
    todos = todo_manager.get_todos_for_date(date)
    
    # åˆ›å»ºdocsæ–‡ä»¶å¤¹
    docs_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'docs')
    if not os.path.exists(docs_dir):
        os.makedirs(docs_dir)
    
    # ç”Ÿæˆmarkdownå†…å®¹
    date_obj = datetime.strptime(date, '%Y-%m-%d')
    formatted_date = date_obj.strftime('%m.%d')
    
    content = f"# {formatted_date} Todo\n\n"
    
    if not todos:
        content += "ä»Šæ—¥æ— ä»»åŠ¡\n"
    else:
        completed_todos = [t for t in todos if t['completed']]
        pending_todos = [t for t in todos if not t['completed']]
        
        if pending_todos:
            content += "## å¾…å®Œæˆ\n\n"
            for todo in pending_todos:
                content += f"- [ ] {todo['content']}\n"
            content += "\n"
        
        if completed_todos:
            content += "## å·²å®Œæˆ\n\n"
            for todo in completed_todos:
                content += f"- [x] {todo['content']}\n"
            content += "\n"
        
        content += f"---\næ€»è®¡: {len(todos)} é¡¹ä»»åŠ¡ï¼Œå·²å®Œæˆ: {len(completed_todos)} é¡¹\n"
    
    # ä¿å­˜æ–‡ä»¶
    filename = f"{formatted_date}-todo.md"
    filepath = os.path.join(docs_dir, filename)
    
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)
    
    return send_file(filepath, as_attachment=True, download_name=filename)

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\run_flask_todo.bat
å†…å®¹:
@echo off

:: åˆ‡æ¢åˆ°é¡¹ç›®æ–‡ä»¶å¤¹
cd /d "C:\Users\Administrator\Work\flask_todo_app"

:: æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ
call todo_venv\Scripts\activate.bat

start /B pythonw app.pyw

@REM # ä¸´æ—¶è°ƒè¯•ï¼Œç«¯å£æ˜¯ 5990
@REM # å¼€æœºè¿è¡Œï¼Œç«¯å£æ˜¯ 5995

@REM æŠŠè¿™ä¸ª bat æ–‡ä»¶, å¤åˆ¶ä¸€ä»½ï¼Œæ”¾åˆ°å¯åŠ¨ç›®å½•
@REM C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup 




å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\start_repo.py
å†…å®¹:
import os
import subprocess
import json
import requests
from dotenv import load_dotenv  # pip install python-dotenv

# åŠ è½½ .env æ–‡ä»¶
load_dotenv()

# ä» .env æ–‡ä»¶è¯»å– GitHub Personal Access Token
GITHUB_USER = "buxuele"
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")

gitignore_content = """# é»˜è®¤ .gitignore æ–‡ä»¶ï¼Œç”± start_repo.py åˆ›å»º
# è¯·ç¼–è¾‘æ­¤æ–‡ä»¶ä»¥æ·»åŠ éœ€è¦å¿½ç•¥çš„æ–‡ä»¶æˆ–ç›®å½•
node_modules/
*.log
*.pyc
__pycache__/

# æ–‡ä»¶å¤¹
.idea/
instance/
flask_venv/
static/uploads/

# ä¸€äº›å…³é”®æ–‡ä»¶ï¼ï¼
*.json
*.bak
.env

*.pyc
*.pyw
*.bat

start_repo.py
gg.bat


"""


def run_command(command):
    """è¿è¡Œç³»ç»Ÿå‘½ä»¤å¹¶è¿”å›è¾“å‡º"""
    print(f"ğŸ“¢ æ‰§è¡Œå‘½ä»¤: {command}")
    result = subprocess.run(command, shell=True, text=True, encoding="utf-8", errors="ignore")
    print(f"å‘½ä»¤è¾“å‡º: {result.stdout}")
    if result.stderr:
        print(f"å‘½ä»¤é”™è¯¯: {result.stderr}")
    if result.returncode != 0:
        print(f"ğŸ˜µ å‘½ä»¤ '{command}' å¤±è´¥ï¼Œé€€å‡ºç : {result.returncode}")
        exit(1)
    return result.stdout


def check_repository_exists(repo_name):
    """æ£€æŸ¥ GitHub ä»“åº“æ˜¯å¦å­˜åœ¨"""
    print(f"ğŸ“¢ æ£€æŸ¥ä»“åº“ '{repo_name}' æ˜¯å¦å­˜åœ¨...")
    url = f"https://api.github.com/repos/{GITHUB_USER}/{repo_name}"
    headers = {"Authorization": f"token {GITHUB_TOKEN}"}
    response = requests.get(url, headers=headers)
    print(f"ğŸ“¢ API å“åº”çŠ¶æ€ç : {response.status_code}")

    if response.status_code == 200:
        print(f"ğŸ‰ ä»“åº“ '{repo_name}' å·²å­˜åœ¨ï¼Œå°†ç›´æ¥ä½¿ç”¨ï¼")
        return True, response.json().get("html_url") + ".git"
    elif response.status_code == 404:
        print(f"ğŸ“¢ ä»“åº“ '{repo_name}' ä¸å­˜åœ¨ï¼Œå°†åˆ›å»ºæ–°ä»“åº“ã€‚")
        return False, None
    else:
        print(f"ğŸ˜µ æ£€æŸ¥ä»“åº“å¤±è´¥ï¼Œé”™è¯¯ä¿¡æ¯: {response.json().get('message', 'æœªçŸ¥é”™è¯¯')}")
        exit(1)


def create_repository(repo_name, description):
    """é€šè¿‡ GitHub API åˆ›å»ºæ–°ä»“åº“"""
    print(f"ğŸ“¢ åˆ›å»ºæ–°ä»“åº“ '{repo_name}'...")
    url = "https://api.github.com/user/repos"
    headers = {"Authorization": f"token {GITHUB_TOKEN}", "Accept": "application/vnd.github.v3+json"}
    data = {
        "name": repo_name,
        "description": description or "",
        "private": False
    }
    response = requests.post(url, headers=headers, json=data)
    print(f"ğŸ“¢ API åˆ›å»ºå“åº”çŠ¶æ€ç : {response.status_code}")

    if response.status_code == 201:
        print(f"ğŸ‰ æ–°ä»“åº“ '{repo_name}' åˆ›å»ºæˆåŠŸï¼")
        return response.json().get("html_url") + ".git"
    else:
        print(f"ğŸ˜µ åˆ›å»ºä»“åº“å¤±è´¥ï¼Œé”™è¯¯ä¿¡æ¯: {response.json().get('message', 'æœªçŸ¥é”™è¯¯')}")
        exit(1)


def create_gitignore():
    """åˆ›å»ºé»˜è®¤ .gitignore æ–‡ä»¶"""

    if not os.path.exists(".gitignore"):
        with open(".gitignore", "w", encoding="utf-8") as f:
            f.write(gitignore_content)
        print("ğŸ“¢ å·²åˆ›å»º .gitignore æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥å¹¶ç¼–è¾‘ï¼")
    else:
        print("ğŸ“¢ .gitignore æ–‡ä»¶å·²å­˜åœ¨ï¼Œè¯·æ£€æŸ¥æ˜¯å¦éœ€è¦ä¿®æ”¹ï¼")


def main():
    # æ£€æŸ¥ Token æ˜¯å¦æœ‰æ•ˆ
    if not GITHUB_TOKEN:
        print("ğŸ˜µ é”™è¯¯ï¼šæœªåœ¨ .env æ–‡ä»¶ä¸­æ‰¾åˆ° GITHUB_TOKENï¼è¯·ç¡®ä¿ .env æ–‡ä»¶å­˜åœ¨å¹¶åŒ…å«æœ‰æ•ˆçš„ Tokenã€‚")
        exit(1)

    # è·å–å½“å‰æ–‡ä»¶å¤¹åç§°ä½œä¸ºé»˜è®¤ä»“åº“å
    default_repo_name = os.path.basename(os.getcwd())
    print(f"ğŸ“¢ é»˜è®¤ä»“åº“åç§°: {default_repo_name}")

    # æ£€æŸ¥ä»“åº“æ˜¯å¦å­˜åœ¨
    repo_exists, remote_url = check_repository_exists(default_repo_name)

    # å¦‚æœä»“åº“ä¸å­˜åœ¨ï¼Œè¯¢é—®ç”¨æˆ·æ˜¯å¦åˆ›å»º
    if not repo_exists:
        use_default = input(f"æ˜¯å¦ä½¿ç”¨é»˜è®¤ä»“åº“åç§° '{default_repo_name}'ï¼Ÿ(y/n): ").strip().lower()
        if use_default == "y":
            repo_name = default_repo_name
        else:
            repo_name = input("è¯·è¾“å…¥ä»“åº“åç§°: ").strip()
            if not repo_name:
                print("ğŸ˜µ é”™è¯¯ï¼šä»“åº“åç§°ä¸èƒ½ä¸ºç©ºï¼")
                exit(1)
        description = input("è¯·è¾“å…¥ä»“åº“æè¿°ï¼ˆå¯é€‰ï¼ŒæŒ‰å›è½¦è·³è¿‡ï¼‰: ").strip()
        remote_url = create_repository(repo_name, description)
    else:
        repo_name = default_repo_name

    print(f"ğŸ“¢ è¿œç¨‹ä»“åº“åœ°å€: {remote_url}")

    if "README.md" not in os.listdir():
        # åˆ›å»º README.md
        print("ğŸ“¢ åˆ›å»º README.md æ–‡ä»¶...")
        with open("README.md", "w", encoding="utf-8") as f:
            f.write(f"# {repo_name}\n")

    # åˆå§‹åŒ– Git ä»“åº“
    print("ğŸ“¢ åˆå§‹åŒ– Git ä»“åº“...")
    run_command("git init")
    run_command("git branch -M main")

    # åˆ›å»ºæˆ–æ£€æŸ¥ .gitignore
    create_gitignore()

    # æ˜¾ç¤º git status å¹¶æš‚åœ
    print("\nğŸ“‹ å½“å‰ Git çŠ¶æ€ï¼š")
    run_command("git status")
    input("è¯·æ£€æŸ¥ git status å’Œ .gitignore æ–‡ä»¶ï¼Œç¼–è¾‘åæŒ‰å›è½¦ç»§ç»­...")

    # æ·»åŠ æ‰€æœ‰æ›´æ”¹
    print("ğŸ“¢ æ·»åŠ æ‰€æœ‰æ›´æ”¹...")
    run_command("git add .")

    # æäº¤æ›´æ”¹
    commit_msg = input("è¯·è¾“å…¥æäº¤ä¿¡æ¯ï¼ˆé»˜è®¤ï¼šokï¼‰: ").strip() or "ok"
    print(f"ğŸ“¢ ä½¿ç”¨æäº¤ä¿¡æ¯: {commit_msg}")
    run_command(f'git commit -m "{commit_msg}"')

    # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ origin
    print("ğŸ“¢ æ£€æŸ¥è¿œç¨‹ä»“åº“ 'origin'...")
    result = subprocess.run("git remote get-url origin", shell=True, text=True, capture_output=True, encoding="utf-8",
                            errors="ignore")
    if result.returncode == 0:
        print("ğŸ“¢ è¿œç¨‹ä»“åº“ 'origin' å·²å­˜åœ¨ï¼Œè·³è¿‡æ·»åŠ ã€‚")
    else:
        print(f"ğŸ“¢ æ·»åŠ è¿œç¨‹ä»“åº“: {remote_url}")
        run_command(f"git remote add origin {remote_url}")

    # æ¨é€ä»£ç 
    print("ğŸ“¢ æ­£åœ¨æ¨é€ä»£ç åˆ°è¿œç¨‹ä»“åº“...")
    run_command("git push -u origin main")

    # æ˜¾ç¤ºæœ€ç»ˆçŠ¶æ€
    print("\nğŸ“‹ æœ€ç»ˆ Git çŠ¶æ€ï¼š")
    run_command("git status")
    print("ğŸ‰ æå®šå•¦ï¼ä»“åº“å·²åˆ›å»ºå¹¶æ¨é€æˆåŠŸï¼")


if __name__ == "__main__":
    main()


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\test_copy_fix.py
å†…å®¹:
#!/usr/bin/env python3
"""
æµ‹è¯•å¤åˆ¶è¡¨åŠŸèƒ½çš„ä¿®å¤
"""
import requests
import json
import time

BASE_URL = "http://127.0.0.1:5990/api"

def test_copy_and_rename():
    """æµ‹è¯•å¤åˆ¶å’Œé‡å‘½ååŠŸèƒ½"""
    print("=" * 60)
    print("æµ‹è¯•å¤åˆ¶è¡¨åŠŸèƒ½ä¿®å¤")
    print("=" * 60)
    
    # 1. åˆ›å»ºä¸€ä¸ªæµ‹è¯•æ—¥æœŸï¼ˆ7æœˆ29æ—¥ï¼‰
    test_date = "2025-07-29"
    print(f"1. æµ‹è¯•æ—¥æœŸ: {test_date}")
    
    # æ·»åŠ ä¸€ä¸ªæµ‹è¯•ä»»åŠ¡
    response = requests.post(f"{BASE_URL}/todos", json={
        "content": "æµ‹è¯•ä»»åŠ¡",
        "date": test_date
    })
    print(f"   æ·»åŠ æµ‹è¯•ä»»åŠ¡: {response.status_code}")
    
    # 2. å¤åˆ¶è¿™ä¸ªæ—¥æœŸçš„è¡¨
    timestamp = int(time.time() * 1000)
    copy_id = f"copy-20250729-{timestamp}"
    
    response = requests.post(f"{BASE_URL}/copy-date", json={
        "source_date": test_date,
        "target_date": copy_id
    })
    print(f"2. å¤åˆ¶è¡¨: {response.status_code}")
    if response.status_code == 200:
        print(f"   å¤åˆ¶æˆåŠŸ: {response.json()}")
    else:
        print(f"   å¤åˆ¶å¤±è´¥: {response.text}")
        return
    
    # 3. ä¸ºå¤åˆ¶çš„è¡¨è®¾ç½®åˆ«å
    alias_name = "7æœˆ29æ—¥-copy"
    response = requests.post(f"{BASE_URL}/date-aliases", json={
        "date": copy_id,
        "alias": alias_name
    })
    print(f"3. è®¾ç½®åˆ«å '{alias_name}': {response.status_code}")
    if response.status_code == 200:
        print(f"   åˆ«åè®¾ç½®æˆåŠŸ: {response.json()}")
    else:
        print(f"   åˆ«åè®¾ç½®å¤±è´¥: {response.text}")
        return
    
    # 4. é‡å‘½åä¸º"ç”Ÿæ´»"
    new_alias = "ç”Ÿæ´»"
    response = requests.post(f"{BASE_URL}/date-aliases", json={
        "date": copy_id,
        "alias": new_alias
    })
    print(f"4. é‡å‘½åä¸º '{new_alias}': {response.status_code}")
    if response.status_code == 200:
        print(f"   é‡å‘½åæˆåŠŸ: {response.json()}")
    else:
        print(f"   é‡å‘½åå¤±è´¥: {response.text}")
        return
    
    # 5. å†æ¬¡å¤åˆ¶"ç”Ÿæ´»"è¡¨
    timestamp2 = int(time.time() * 1000)
    copy_id2 = f"copy-20250729-{timestamp2}"
    
    response = requests.post(f"{BASE_URL}/copy-date", json={
        "source_date": copy_id,  # ä½¿ç”¨ç¬¬ä¸€æ¬¡å¤åˆ¶çš„IDä½œä¸ºæº
        "target_date": copy_id2
    })
    print(f"5. å†æ¬¡å¤åˆ¶ 'ç”Ÿæ´»' è¡¨: {response.status_code}")
    if response.status_code == 200:
        print(f"   å¤åˆ¶æˆåŠŸ: {response.json()}")
    else:
        print(f"   å¤åˆ¶å¤±è´¥: {response.text}")
        return
    
    # 6. ä¸ºç¬¬äºŒæ¬¡å¤åˆ¶è®¾ç½®åˆ«å
    alias_name2 = "ç”Ÿæ´»-copy"
    response = requests.post(f"{BASE_URL}/date-aliases", json={
        "date": copy_id2,
        "alias": alias_name2
    })
    print(f"6. è®¾ç½®åˆ«å '{alias_name2}': {response.status_code}")
    if response.status_code == 200:
        print(f"   åˆ«åè®¾ç½®æˆåŠŸ: {response.json()}")
    else:
        print(f"   åˆ«åè®¾ç½®å¤±è´¥: {response.text}")
        return
    
    print("\n" + "=" * 60)
    print("æµ‹è¯•å®Œæˆï¼æ‰€æœ‰æ­¥éª¤éƒ½æˆåŠŸæ‰§è¡Œã€‚")
    print("=" * 60)
    
    # 7. éªŒè¯æ‰€æœ‰è¡¨éƒ½å­˜åœ¨
    print("\néªŒè¯åˆ›å»ºçš„è¡¨:")
    for date_id, name in [(test_date, "åŸå§‹è¡¨"), (copy_id, "ç”Ÿæ´»"), (copy_id2, "ç”Ÿæ´»-copy")]:
        response = requests.get(f"{BASE_URL}/todos?date={date_id}")
        if response.status_code == 200:
            todos = response.json()
            print(f"   {name} ({date_id}): {len(todos)} ä¸ªä»»åŠ¡")
        else:
            print(f"   {name} ({date_id}): è·å–å¤±è´¥")

if __name__ == "__main__":
    test_copy_and_rename()

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\test_copy_issue.py
å†…å®¹:
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
æµ‹è¯•å¤åˆ¶åŠŸèƒ½çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
"""

import os
import sys
import sqlite3
from datetime import datetime, timedelta
import json

# æ·»åŠ å½“å‰ç›®å½•åˆ°è·¯å¾„
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from models import DailyTodoManager, DateAlias, db
from flask import Flask
from config import Config

def setup_test_app(test_name="test"):
    """è®¾ç½®æµ‹è¯•åº”ç”¨"""
    app = Flask(__name__)
    app.config.from_object(Config)
    
    # ä½¿ç”¨æµ‹è¯•æ•°æ®åº“
    instance_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'instance')
    os.makedirs(instance_dir, exist_ok=True)
    test_db_path = os.path.join(instance_dir, f'{test_name}_todos.db')
    
    # å¦‚æœæµ‹è¯•æ•°æ®åº“å­˜åœ¨ï¼Œåˆ é™¤å®ƒ
    if os.path.exists(test_db_path):
        try:
            os.remove(test_db_path)
        except PermissionError:
            # å¦‚æœæ— æ³•åˆ é™¤ï¼Œä½¿ç”¨æ—¶é—´æˆ³åˆ›å»ºæ–°æ–‡ä»¶å
            import time
            timestamp = int(time.time())
            test_db_path = os.path.join(instance_dir, f'{test_name}_{timestamp}_todos.db')
    
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{test_db_path}'
    db.init_app(app)
    
    return app, test_db_path

def test_current_copy_issue():
    """æµ‹è¯•å½“å‰å¤åˆ¶åŠŸèƒ½çš„é—®é¢˜"""
    print("=" * 60)
    print("æµ‹è¯•å½“å‰å¤åˆ¶åŠŸèƒ½çš„é—®é¢˜")
    print("=" * 60)
    
    app, test_db_path = setup_test_app("current_issue")
    
    with app.app_context():
        # åˆ›å»ºæ•°æ®åº“è¡¨
        db.create_all()
        
        # åˆ›å»ºæµ‹è¯•ç®¡ç†å™¨
        manager = DailyTodoManager(test_db_path)
        
        # æ¨¡æ‹Ÿä»Šå¤©æ˜¯7æœˆ28æ—¥
        today = "2025-07-28"
        source_date = "2025-07-24"  # è¦å¤åˆ¶çš„æ—¥æœŸ
        
        print(f"1. åˆ›å»ºæºæ—¥æœŸ {source_date} çš„ä»»åŠ¡")
        manager.add_todo(source_date, "ä»»åŠ¡1 - åŸå§‹")
        manager.add_todo(source_date, "ä»»åŠ¡2 - åŸå§‹")
        
        # æ˜¾ç¤ºæºæ—¥æœŸçš„ä»»åŠ¡
        source_todos = manager.get_todos_for_date(source_date)
        print(f"   æºæ—¥æœŸ {source_date} æœ‰ {len(source_todos)} ä¸ªä»»åŠ¡:")
        for todo in source_todos:
            print(f"   - {todo['content']}")
        
        print(f"\n2. æ¨¡æ‹Ÿæ—§çš„å¤åˆ¶é€»è¾‘ - å¯»æ‰¾æ˜å¤©çš„ç©ºé—²æ—¥æœŸ")
        
        # è·å–ç°æœ‰æ—¥æœŸ
        existing_dates = manager.get_available_dates()
        print(f"   ç°æœ‰æ—¥æœŸ: {existing_dates}")
        
        # ä»æ˜å¤©å¼€å§‹æ‰¾ç©ºé—²æ—¥æœŸï¼ˆæ—§é€»è¾‘ï¼‰
        tomorrow = datetime.strptime(today, '%Y-%m-%d') + timedelta(days=1)
        target_date = tomorrow.strftime('%Y-%m-%d')  # 2025-07-29
        
        print(f"   æ‰¾åˆ°çš„ç›®æ ‡æ—¥æœŸ: {target_date}")
        
        # å¤åˆ¶ä»»åŠ¡åˆ°ç›®æ ‡æ—¥æœŸ
        print(f"\n3. å¤åˆ¶ä»»åŠ¡åˆ° {target_date}")
        for todo in source_todos:
            manager.add_todo(target_date, todo['content'])
        
        # è®¾ç½®åˆ«å
        alias_entry = DateAlias(date=target_date, alias="7æœˆ24æ—¥-copy")
        db.session.add(alias_entry)
        db.session.commit()
        
        print(f"   å·²è®¾ç½®åˆ«å: {target_date} -> '7æœˆ24æ—¥-copy'")
        
        # æ˜¾ç¤ºå¤åˆ¶åçš„çŠ¶æ€
        target_todos = manager.get_todos_for_date(target_date)
        print(f"   ç›®æ ‡æ—¥æœŸ {target_date} æœ‰ {len(target_todos)} ä¸ªä»»åŠ¡:")
        for todo in target_todos:
            print(f"   - {todo['content']}")
        
        print(f"\n4. é—®é¢˜æ¼”ç¤ºï¼šå½“çœŸæ­£åˆ°äº† {target_date} æ—¶")
        print(f"   ç³»ç»Ÿä¼šå°è¯•ä¸º {target_date} åˆ›å»ºä»Šæ—¥ä»»åŠ¡è¡¨")
        print(f"   ä½†å‘ç°è¡¨å·²ç»å­˜åœ¨ï¼ˆè¢«å¤åˆ¶åŠŸèƒ½å ç”¨ï¼‰")
        print(f"   è¿™ä¼šå¯¼è‡´é€»è¾‘å†²çªï¼")
        
        # æ˜¾ç¤ºæ‰€æœ‰è¡¨
        conn = sqlite3.connect(test_db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'todo_%'")
        tables = cursor.fetchall()
        conn.close()
        
        print(f"\n   å½“å‰æ•°æ®åº“ä¸­çš„è¡¨:")
        for table in tables:
            table_name = table[0]
            date_str = table_name.replace('todo_', '').replace('_', '-')
            print(f"   - {table_name} (å¯¹åº”æ—¥æœŸ: {date_str})")

def test_new_copy_solution():
    """æµ‹è¯•æ–°çš„å¤åˆ¶è§£å†³æ–¹æ¡ˆ"""
    print("\n" + "=" * 60)
    print("æµ‹è¯•æ–°çš„å¤åˆ¶è§£å†³æ–¹æ¡ˆ")
    print("=" * 60)
    
    app, test_db_path = setup_test_app("new_solution")
    
    with app.app_context():
        # åˆ›å»ºæ•°æ®åº“è¡¨
        db.create_all()
        
        # åˆ›å»ºæµ‹è¯•ç®¡ç†å™¨
        manager = DailyTodoManager(test_db_path)
        
        # æ¨¡æ‹Ÿä»Šå¤©æ˜¯7æœˆ28æ—¥
        today = "2025-07-28"
        source_date = "2025-07-24"  # è¦å¤åˆ¶çš„æ—¥æœŸ
        
        print(f"1. åˆ›å»ºæºæ—¥æœŸ {source_date} çš„ä»»åŠ¡")
        manager.add_todo(source_date, "ä»»åŠ¡1 - åŸå§‹")
        manager.add_todo(source_date, "ä»»åŠ¡2 - åŸå§‹")
        
        # æ˜¾ç¤ºæºæ—¥æœŸçš„ä»»åŠ¡
        source_todos = manager.get_todos_for_date(source_date)
        print(f"   æºæ—¥æœŸ {source_date} æœ‰ {len(source_todos)} ä¸ªä»»åŠ¡:")
        for todo in source_todos:
            print(f"   - {todo['content']}")
        
        print(f"\n2. ä½¿ç”¨æ–°çš„å¤åˆ¶é€»è¾‘ - ç”Ÿæˆå”¯ä¸€æ ‡è¯†ç¬¦")
        
        # ç”Ÿæˆå”¯ä¸€çš„å¤åˆ¶æ ‡è¯†ç¬¦ï¼ˆæ–°é€»è¾‘ï¼‰
        timestamp = int(datetime.now().timestamp() * 1000)  # æ¯«ç§’æ—¶é—´æˆ³
        today_obj = datetime.strptime(today, '%Y-%m-%d')
        date_prefix = today_obj.strftime('%Y%m%d')
        unique_id = f"copy-{date_prefix}-{timestamp}"
        
        print(f"   ç”Ÿæˆçš„å”¯ä¸€æ ‡è¯†ç¬¦: {unique_id}")
        
        # å¤åˆ¶ä»»åŠ¡åˆ°å”¯ä¸€æ ‡è¯†ç¬¦
        print(f"\n3. å¤åˆ¶ä»»åŠ¡åˆ°å”¯ä¸€æ ‡è¯†ç¬¦ {unique_id}")
        for todo in source_todos:
            manager.add_todo(unique_id, todo['content'])
        
        # è®¾ç½®åˆ«å
        alias_entry = DateAlias(date=unique_id, alias="7æœˆ24æ—¥-copy")
        db.session.add(alias_entry)
        db.session.commit()
        
        print(f"   å·²è®¾ç½®åˆ«å: {unique_id} -> '7æœˆ24æ—¥-copy'")
        
        # æ˜¾ç¤ºå¤åˆ¶åçš„çŠ¶æ€
        target_todos = manager.get_todos_for_date(unique_id)
        print(f"   ç›®æ ‡æ ‡è¯†ç¬¦ {unique_id} æœ‰ {len(target_todos)} ä¸ªä»»åŠ¡:")
        for todo in target_todos:
            print(f"   - {todo['content']}")
        
        print(f"\n4. è§£å†³æ–¹æ¡ˆéªŒè¯ï¼šå½“çœŸæ­£åˆ°äº† 2025-07-29 æ—¶")
        future_date = "2025-07-29"
        print(f"   ç³»ç»Ÿå¯ä»¥æ­£å¸¸ä¸º {future_date} åˆ›å»ºä»Šæ—¥ä»»åŠ¡è¡¨")
        manager.add_todo(future_date, "7æœˆ29æ—¥çš„æ­£å¸¸ä»»åŠ¡")
        
        future_todos = manager.get_todos_for_date(future_date)
        print(f"   {future_date} æœ‰ {len(future_todos)} ä¸ªä»»åŠ¡:")
        for todo in future_todos:
            print(f"   - {todo['content']}")
        
        # æ˜¾ç¤ºæ‰€æœ‰è¡¨
        conn = sqlite3.connect(test_db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'todo_%'")
        tables = cursor.fetchall()
        conn.close()
        
        print(f"\n   å½“å‰æ•°æ®åº“ä¸­çš„è¡¨:")
        for table in tables:
            table_name = table[0]
            identifier = table_name.replace('todo_', '').replace('_', '-')
            if identifier.startswith('copy-'):
                print(f"   - {table_name} (å¤åˆ¶æ ‡è¯†ç¬¦: {identifier})")
            else:
                print(f"   - {table_name} (æ—¥æœŸ: {identifier})")
        
        print(f"\n   âœ… æ²¡æœ‰å†²çªï¼çœŸå®æ—¥æœŸå’Œå¤åˆ¶æ ‡è¯†ç¬¦å®Œå…¨åˆ†ç¦»")

def test_alias_display():
    """æµ‹è¯•åˆ«åæ˜¾ç¤ºåŠŸèƒ½"""
    print("\n" + "=" * 60)
    print("æµ‹è¯•åˆ«åæ˜¾ç¤ºåŠŸèƒ½")
    print("=" * 60)
    
    app, test_db_path = setup_test_app("alias_display")
    
    with app.app_context():
        # åˆ›å»ºæ•°æ®åº“è¡¨
        db.create_all()
        
        # åˆ›å»ºä¸€äº›æµ‹è¯•åˆ«å
        aliases = [
            ("2025-07-24", "å·¥ä½œæ—¥å¿—"),
            ("2025-07-25", "å­¦ä¹ è®¡åˆ’"),
            ("copy-20250728-1234567890", "7æœˆ24æ—¥-copy"),
            ("copy-20250728-1234567891", "å­¦ä¹ è®¡åˆ’-copy")
        ]
        
        for date, alias in aliases:
            alias_entry = DateAlias(date=date, alias=alias)
            db.session.add(alias_entry)
        
        db.session.commit()
        
        print("åˆ›å»ºçš„åˆ«åæ˜ å°„:")
        all_aliases = DateAlias.query.all()
        for alias in all_aliases:
            print(f"   {alias.date} -> '{alias.alias}'")
        
        print(f"\nå‰ç«¯æ˜¾ç¤ºé€»è¾‘:")
        print(f"   - çœŸå®æ—¥æœŸ 2025-07-24 æ˜¾ç¤ºä¸º: 'å·¥ä½œæ—¥å¿—'")
        print(f"   - çœŸå®æ—¥æœŸ 2025-07-25 æ˜¾ç¤ºä¸º: 'å­¦ä¹ è®¡åˆ’'")
        print(f"   - å¤åˆ¶æ ‡è¯†ç¬¦ copy-20250728-1234567890 æ˜¾ç¤ºä¸º: '7æœˆ24æ—¥-copy'")
        print(f"   - å¤åˆ¶æ ‡è¯†ç¬¦ copy-20250728-1234567891 æ˜¾ç¤ºä¸º: 'å­¦ä¹ è®¡åˆ’-copy'")
        print(f"   - ç”¨æˆ·çœ‹åˆ°çš„æ˜¯æœ‰æ„ä¹‰çš„åç§°ï¼Œè€Œä¸æ˜¯æŠ€æœ¯æ ‡è¯†ç¬¦")

def main():
    """ä¸»å‡½æ•°"""
    print("Flask Todo App - å¤åˆ¶åŠŸèƒ½é—®é¢˜åˆ†æå’Œè§£å†³æ–¹æ¡ˆæµ‹è¯•")
    print("æ—¶é—´:", datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
    
    try:
        # æµ‹è¯•å½“å‰é—®é¢˜
        test_current_copy_issue()
        
        # æµ‹è¯•è§£å†³æ–¹æ¡ˆ
        test_new_copy_solution()
        
        # æµ‹è¯•åˆ«åæ˜¾ç¤º
        test_alias_display()
        
        print("\n" + "=" * 60)
        print("æ€»ç»“")
        print("=" * 60)
        print("é—®é¢˜:")
        print("  - æ—§çš„å¤åˆ¶é€»è¾‘ä½¿ç”¨æœªæ¥æ—¥æœŸä½œä¸ºè¡¨å")
        print("  - å½“çœŸæ­£åˆ°è¾¾è¯¥æ—¥æœŸæ—¶ä¼šäº§ç”Ÿå†²çª")
        print("  - è¡¨åä¸æ˜¾ç¤ºåä¸ä¸€è‡´ï¼Œé€ æˆæ··æ·†")
        print()
        print("è§£å†³æ–¹æ¡ˆ:")
        print("  - ä½¿ç”¨å”¯ä¸€æ—¶é—´æˆ³æ ‡è¯†ç¬¦ (copy-YYYYMMDD-timestamp)")
        print("  - å®Œå…¨é¿å…ä¸çœŸå®æ—¥æœŸçš„å†²çª")
        print("  - é€šè¿‡åˆ«åç³»ç»Ÿæä¾›æœ‰æ„ä¹‰çš„æ˜¾ç¤ºåç§°")
        print("  - ä¿æŒæ•°æ®åº“è¡¨åçš„å”¯ä¸€æ€§å’Œä¸€è‡´æ€§")
        print()
        print("âœ… æµ‹è¯•å®Œæˆï¼æ–°æ–¹æ¡ˆå¯ä»¥è§£å†³è¡¨åå†²çªé—®é¢˜ã€‚")
        
    except Exception as e:
        print(f"âŒ æµ‹è¯•å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\todo.md
å†…å®¹:
### todo



æ­¤æ—¶çš„é—®é¢˜æ˜¯ã€‚ 

å‡è®¾ä»Šå¤©æ˜¯ 7æœˆ28æ—¥ï¼Œ
æˆ‘å¦‚æœå¤åˆ¶ä¸€ä¸ªè¡¨ï¼Œæ¯”å¦‚å¤åˆ¶ 7æœˆ24æ—¥ï¼Œ
è¡¨é¢ä¸Šå¾—åˆ°çš„æ˜¯ 7æœˆ24æ—¥-copy,
é‚£ä¹ˆå®é™…ä¸Šä¼šç”¨æ˜å¤©çš„æ—¥æœŸæ¥ä½œä¸ºè¡¨åï¼Œ å³ï¼Œå®é™…çš„è¡¨åæ˜¯ 7æœˆ29æ—¥ã€‚

é‚£ä¹ˆåˆ°äº†æ˜å¤©ï¼ŒæŒ‰ç†åº”è¯¥æ–°å»ºä¸€ä¸ª ç©ºç™½çš„ 7æœˆ29æ—¥ï¼Œ
ä½†æ˜¯ç³»ç»Ÿä¸€æ£€æŸ¥ï¼Œå·²ç»å­˜åœ¨äº†ï¼Œ æ‰€ä»¥è¿™é‡Œæœ‰ä¸ªé€»è¾‘ä¸Šçš„é—®é¢˜ã€‚

è¯·æ£€æŸ¥ã€‚

è¿™é‡Œèƒ½å¦æ”¹ä¸ºï¼Œä½¿ç”¨ä¸¥æ ¼çš„ï¼Œå”¯ä¸€çš„è¡¨åã€‚
å³ï¼Œå®é™…æ˜¾ç¤ºçš„è¡¨åï¼Œä¸æ•°æ®åº“ä¸­å­˜å‚¨çš„è¡¨åï¼Œåº”è¯¥æ˜¯ä¸€è‡´çš„ã€‚
å³ä¾¿æ˜¯ä¸ä¸€è‡´ï¼Œåº”è¯¥ç”¨ä¸€ä¸ªç‰¹æ®Šçš„æ˜ å°„è¡¨æ¥è®°å½•ã€‚
æ¯”å¦‚å¯¹æ¯ä¸ªè¡¨åï¼Œå¢åŠ ä¸€ä¸ª hash å€¼ï¼Œç”¨æ¥è®°å½•çš„å®ƒçš„èµ·æºã€‚

 


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\è¯´æ˜.md
å†…å®¹:


## æŠŠ flask app, éƒ¨ç½²åˆ° vercel 
- æ˜¯å¯è¡Œçš„ã€‚
- èŠå¤©ï¼šhttps://aistudio.google.com/prompts/1uTv5R00MTFMPLQlyjkP5N4pP2DBXtgBC
- ä½†æ˜¯æˆ‘è§‰å¾—ï¼Œæˆ‘æƒ³æ–°å»ºä¸€ä¸ªé¡¹ç›®ï¼Œvercel_flask_todo_app ? 


### todo app 

- æ­¤é¡¹ç›®è™½ç„¶çœ‹èµ·æ¥ç®€å•ï¼Œå®é™…ä¸Šï¼Œä¿®æ”¹æˆè‡ªå·±å–œæ¬¢çš„æ ·å­ï¼Œä¹Ÿæ˜¯è´¹æ—¶é—´çš„ã€‚
- åˆ«äººéƒ½æAI ç›¸å…³çš„é¡¹ç›®ï¼Œè€Œæˆ‘è¿˜æ˜¯æè¿™ç§åŸºç¡€çš„ä¸œè¥¿ã€‚ä¸è¦ç°å¿ƒã€‚
- ç§¯ç´¯ã€‚å°±æ˜¯ä¸è®ºé¡¹ç›®å¤§å°ï¼Œä¸è®ºéš¾æ˜“ï¼Œåªçœ‹æ˜¯å¦æœ‰ç”¨ã€‚
- ä¸“ä¸šçš„å¨å¸ˆï¼Œæ— è®ºæ˜¯åˆ‡èœè¿˜æ˜¯æ€é±¼ï¼Œæ€»æ˜¯é€‰æ‹©æœ€åˆé€‚çš„åˆ€ã€‚


### æ­¤ app çš„èµ·å› 
- æˆ‘éœ€è¦è®°å½•è‡ªå·±æ¯å¤©åšäº†ä»€ä¹ˆã€‚æ‰“ç®—åšä»€ä¹ˆã€‚ä»¥åŠä¸€äº›æƒ³æ³•ã€‚
- å›é¡¾æ£€æŸ¥ã€‚
- æ¯æ—¥å·¥ä½œæ—¥å¿—ã€‚


- æ­¤ app æœ€ç®€å•ï¼Œåè€Œæ˜¯æˆ‘æœ€å–œæ¬¢çš„ app. 
- è¿™ä¸ªç®€å•çš„äº‹æƒ…ï¼Œæ€»æ˜¯è®©æˆ‘æƒ³èµ·æ¥å“ªä¸ªå¤§å¨ï¼Œåšäº†ä¸€é“å¾ˆç®€å•çš„é£Ÿç‰©ã€‚æ¯”å¦‚èŠå£«ä¸‰æ˜æ²»ï¼Œæˆ–æ˜¯å«©å«©çš„æ»‘è›‹å·ã€‚ã€‚



ç›®å½•: docs
å†…å®¹: æ­¤ç›®å½•ä¸ºç©º

ç›®å½•: instance
å†…å®¹: [è¿™æ˜¯ä¸€ä¸ªç›®å½•]

ç›®å½•: services
å†…å®¹: [è¿™æ˜¯ä¸€ä¸ªç›®å½•]

ç›®å½•: static
å†…å®¹: [è¿™æ˜¯ä¸€ä¸ªç›®å½•]

ç›®å½•: templates
å†…å®¹: [è¿™æ˜¯ä¸€ä¸ªç›®å½•]

ç›®å½•: utils
å†…å®¹: [è¿™æ˜¯ä¸€ä¸ªç›®å½•]

ç›®å½•: æ•ˆæœå›¾
å†…å®¹: [è¿™æ˜¯ä¸€ä¸ªç›®å½•]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\instance\alias_display_todos.db
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\instance\current_issue_todos.db
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\instance\new_solution_todos.db
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\instance\test_todos.db
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\instance\todos_new.db
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\services\database_service.py
å†…å®¹:
"""
ç»Ÿä¸€çš„æ•°æ®åº“æœåŠ¡å±‚
"""
import sqlite3
import os
from contextlib import contextmanager
from typing import List, Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)

class DatabaseService:
    """ç»Ÿä¸€çš„æ•°æ®åº“æœåŠ¡"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.ensure_db_exists()
    
    def ensure_db_exists(self):
        """ç¡®ä¿æ•°æ®åº“æ–‡ä»¶å­˜åœ¨"""
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
    
    @contextmanager
    def get_connection(self):
        """è·å–æ•°æ®åº“è¿æ¥çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = sqlite3.Row  # ä½¿ç»“æœå¯ä»¥é€šè¿‡åˆ—åè®¿é—®
            yield conn
        except Exception as e:
            if conn:
                conn.rollback()
            logger.error(f"æ•°æ®åº“æ“ä½œå¤±è´¥: {e}")
            raise
        finally:
            if conn:
                conn.close()
    
    def execute_query(self, query: str, params: tuple = None) -> List[Dict[str, Any]]:
        """æ‰§è¡ŒæŸ¥è¯¢å¹¶è¿”å›ç»“æœ"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            return [dict(row) for row in cursor.fetchall()]
    
    def execute_update(self, query: str, params: tuple = None) -> int:
        """æ‰§è¡Œæ›´æ–°æ“ä½œå¹¶è¿”å›å½±å“çš„è¡Œæ•°"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            conn.commit()
            return cursor.rowcount
    
    def execute_insert(self, query: str, params: tuple = None) -> int:
        """æ‰§è¡Œæ’å…¥æ“ä½œå¹¶è¿”å›æ–°è®°å½•çš„ID"""
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            conn.commit()
            return cursor.lastrowid
    
    def table_exists(self, table_name: str) -> bool:
        """æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨"""
        query = """
        SELECT name FROM sqlite_master 
        WHERE type='table' AND name=?
        """
        result = self.execute_query(query, (table_name,))
        return len(result) > 0
    
    def create_table(self, table_name: str, schema: str):
        """åˆ›å»ºè¡¨"""
        query = f"CREATE TABLE IF NOT EXISTS {table_name} ({schema})"
        self.execute_update(query)
    
    def drop_table(self, table_name: str):
        """åˆ é™¤è¡¨"""
        query = f"DROP TABLE IF EXISTS {table_name}"
        self.execute_update(query)

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\favicon.ico
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]

ç›®å½•: static\css
å†…å®¹: [è¿™æ˜¯ä¸€ä¸ªç›®å½•]

ç›®å½•: static\fonts
å†…å®¹: [è¿™æ˜¯ä¸€ä¸ªç›®å½•]

ç›®å½•: static\js
å†…å®¹: [è¿™æ˜¯ä¸€ä¸ªç›®å½•]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\css\style.css
å†…å®¹:
@font-face {
  font-family: "MaruSC";
  src: url("/static/fonts/975MaruSC-Medium.ttf") format("truetype");
  font-weight: normal;
  font-style: normal;
}

body {
  background: #fff3e0;
  font-family: "MaruSC", "Microsoft YaHei", "å¾®è½¯é›…é»‘", Arial, sans-serif;
  margin: 0;
  padding: 0;
  height: 100vh;
  display: flex;
}

.sidebar {
  width: 250px;
  background: #2d2d2d;
  color: #ffffff;
  padding: 20px 0;
  height: 100vh;
  overflow-y: auto;
  border-right: 1px solid #444;
  transition: width 0.3s ease;
}

.sidebar.collapsed {
  width: 60px;
}

.sidebar-header {
  padding: 0 20px 20px 20px;
  border-bottom: 1px solid #444;
  margin-bottom: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.sidebar-header h3 {
  margin: 0;
  font-size: 1.2rem;
  color: #ffffff;
}

.sidebar.collapsed .sidebar-header h3 {
  display: none;
}

.collapse-btn {
  background: none;
  border: none;
  color: #ffffff;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 5px;
  border-radius: 3px;
}

.collapse-btn:hover {
  background: #404040;
}

.date-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.date-item {
  padding: 12px 20px;
  cursor: pointer;
  border-bottom: 1px solid #444;
  transition: background-color 0.2s;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.sidebar.collapsed .date-item {
  padding: 12px 10px;
  justify-content: center;
}

.sidebar.collapsed .date-name {
  display: none;
}

.sidebar.collapsed .todo-count {
  margin: 0;
}

.date-item:hover {
  background-color: #404040;
}

.date-item.active {
  background-color: #0d6efd;
}

.date-item .date-name {
  font-size: 1.14rem; /* 0.95rem * 1.2 = 1.14rem */
}

.date-item .todo-count {
  display: none; /* éšè—è®¡æ•°åœ†åœˆ */
}

/* ç½®é¡¶ç›¸å…³æ ·å¼ */
.date-item.pinned {
  background-color: #1a472a;
  border-left: 3px solid #28a745;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.date-item.pinned:hover {
  background-color: #2d5a3d;
}

.date-item.pinned.active {
  background-color: #0d6efd;
  border-left: 3px solid #28a745;
}

.pin-icon {
  color: #dc3545; /* çº¢è‰²å›¾æ ‡ */
  font-size: 0.9rem;
  margin-left: auto; /* æ¨åˆ°å³è¾¹ */
  flex-shrink: 0;
}

/* ç½®é¡¶é¡¹ç›®çš„åç§°å®¹å™¨ */
.date-item.pinned .date-name {
  flex: 1;
  text-align: left;
}

.main-content {
  flex: 1;
  padding: 48px;
  overflow-y: auto;
}

.container {
  background: #fff7ed;
  border: 1px solid #000;
  border-radius: 16px;
  box-shadow: 0 0 16px #f5c16c33;
  max-width: none;
  margin: 0;
  padding: 40px 36px 36px 36px;
  height: fit-content;
}

.list-group {
  border: none !important;
}

.list-group-item {
  border: 1px solid #000 !important;
  border-radius: 10px !important;
  margin-bottom: 18px;
  font-family: "MaruSC", "Microsoft YaHei", "å¾®è½¯é›…é»‘", Arial, sans-serif;
  padding: 12px 12px 12px 16px;
  display: flex;
  align-items: flex-start;
  min-height: 39px;
  background-color: #fff3e0 !important;
}

.form-control,
.btn {
  border: 1px solid #000 !important;
  border-radius: 8px !important;
}

.input-group {
  border: none !important;
}

.input-group {
  margin-bottom: 24px !important;
}

.form-control {
  padding: 12px 16px;
  font-size: 1.1rem;
  background-color: #fff3e0 !important;
}

.btn {
  font-weight: bold;
  padding: 4px 8px;
  margin-left: 2px;
  font-size: 0.95rem;
  line-height: 22px;
  display: inline-flex;
  align-items: center;
}

.form-control.d-inline {
  height: 100%;
  padding: 0 8px;
  font-size: 1.15rem;
  margin-right: 8px;
  display: inline-block;
  vertical-align: middle;
  flex: 1 1 0%;
  min-width: 60px;
  margin-left: 0;
  border: 1px solid #000 !important;
  border-radius: 8px !important;
  background-color: #fff3e0 !important;
}

.form-control.d-inline:focus {
  border-color: #2979ff !important;
  box-shadow: 0 0 0 1px #90caf9;
  outline: none;
  border-width: 1px;
}

.todo-content {
  cursor: pointer;
  user-select: none;
  transition: color 0.2s;
  font-size: 1.15rem;
  flex: 1;
  word-wrap: break-word;
  white-space: pre-wrap;
  line-height: 1.4;
  margin-right: 12px;
}

.todo-completed {
  text-decoration: line-through;
  color: #888;
}

.todo-dates {
  font-size: 1.15rem;
  color: #b77b00;
  min-width: 120px;
  text-align: right;
  flex-shrink: 0;
  align-self: flex-start;
  line-height: 1.4;
}

.todo-actions {
  margin-left: 8px;
  margin-right: 0px;
  margin-top: -6px;
  display: flex;
  flex-direction: row;
  gap: 2px;
  align-items: flex-start;
  flex-shrink: 0;
  width: 170px;
}

.todo-actions .btn {
  white-space: nowrap;
  text-align: center;
  padding: 6px 8px;
  font-size: 1.15rem;
  line-height: 1.4;
  min-width: 54px;
  flex-shrink: 0;
  margin: 0;
  font-weight: normal;
}

/* å³é”®èœå•æ ·å¼ */
.context-menu {
  position: fixed;
  background: #ffffff;
  border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  min-width: 120px;
  padding: 4px 0;
  display: none;
}

.context-menu-item {
  padding: 8px 16px;
  cursor: pointer;
  font-size: 0.9rem;
  color: #333;
  transition: background-color 0.2s;
}

.context-menu-item:hover {
  background-color: #f5f5f5;
}

.context-menu-item.danger {
  color: #dc3545;
}

.context-menu-item.danger:hover {
  background-color: #f8d7da;
}

/* é€šçŸ¥æç¤ºæ ·å¼ */
.toast-container {
  z-index: 1050;
}

.toast {
  border: 1px solid #000;
  border-radius: 8px;
  font-family: "MaruSC", "Microsoft YaHei", "å¾®è½¯é›…é»‘", Arial, sans-serif;
}

.toast-header {
  border-bottom: 1px solid rgba(0, 0, 0, 0.125);
  font-weight: bold;
}

.toast-body {
  font-size: 0.95rem;
}

@media (max-width: 600px) {
  .container {
    padding: 16px 4px;
  }
  .list-group-item {
    flex-direction: column;
    align-items: flex-start;
    padding: 12px 8px;
  }
  .todo-actions {
    margin-left: 0;
    margin-top: 8px;
  }
}


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\fonts\975MaruSC-Medium.ttf
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\js\config.js
å†…å®¹:
/**
 * åº”ç”¨é…ç½®å’Œå¸¸é‡
 */
const CONFIG = {
  API_BASE: "/api/todos",
  DATE_FORMAT: "YYYY-MM-DD",
  LOCALE: "zh-CN",
};

// è·å–å½“å‰æ—¥æœŸ
const today = new Date();
let currentDate = today.toISOString().split("T")[0]; // å½“å‰é€‰ä¸­çš„æ—¥æœŸ YYYY-MM-DD

// å…¨å±€å˜é‡
let allTodos = []; // å­˜å‚¨æ‰€æœ‰æ—¥æœŸçš„todos
let isSearchMode = false; // æ˜¯å¦å¤„äºæœç´¢æ¨¡å¼
let rightClickedDate = null; // å­˜å‚¨å³é”®ç‚¹å‡»çš„æ—¥æœŸ
let pinnedDates = new Set(); // å­˜å‚¨ç½®é¡¶çš„æ—¥æœŸ


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\js\context-menu.js
å†…å®¹:
/**
 * å³é”®èœå•ç›¸å…³åŠŸèƒ½
 */

// ä¸ºæ—¥æœŸåˆ—è¡¨é¡¹æ·»åŠ å³é”®èœå•äº‹ä»¶
function addContextMenuToDateItem(li, dateStr) {
  li.addEventListener("contextmenu", function (e) {
    e.preventDefault();
    rightClickedDate = dateStr;

    // æ›´æ–°ç½®é¡¶èœå•é¡¹çš„æ–‡æœ¬
    const pinMenuItem = document.getElementById("pin-menu-item");
    if (pinnedDates.has(dateStr)) {
      pinMenuItem.textContent = "å–æ¶ˆç½®é¡¶";
    } else {
      pinMenuItem.textContent = "ç½®é¡¶";
    }

    const contextMenu = document.getElementById("context-menu");
    contextMenu.style.display = "block";
    contextMenu.style.left = e.pageX + "px";
    contextMenu.style.top = e.pageY + "px";
  });
}

// å¤åˆ¶æ—¥æœŸåˆ—è¡¨åŠŸèƒ½ - åˆ›å»ºæ–°çš„ç‹¬ç«‹æ—¥æœŸå‰¯æœ¬ï¼Œä½¿ç”¨å”¯ä¸€æ ‡è¯†ç¬¦é¿å…å†²çª
function copyDateList() {
  if (!rightClickedDate) return;

  // è·å–å½“å‰æ˜¾ç¤ºçš„åç§°ï¼ˆå¯èƒ½æ˜¯åˆ«åï¼‰
  const currentDisplayName = document.querySelector(
    `[data-date="${rightClickedDate}"] .date-name`
  ).textContent;

  // ç”Ÿæˆå”¯ä¸€çš„å¤åˆ¶æ ‡è¯†ç¬¦ï¼šä½¿ç”¨æ—¶é—´æˆ³ç¡®ä¿å”¯ä¸€æ€§
  const timestamp = Date.now();
  const copyName = currentDisplayName + "-copy";

  // ç”Ÿæˆä¸€ä¸ªåŸºäºæ—¶é—´æˆ³çš„å”¯ä¸€"æ—¥æœŸ"æ ‡è¯†ç¬¦
  // æ ¼å¼ï¼šcopy-YYYYMMDD-timestampï¼Œç¡®ä¿ä¸ä¼šä¸çœŸå®æ—¥æœŸå†²çª
  const today = new Date();
  const datePrefix =
    today.getFullYear() +
    String(today.getMonth() + 1).padStart(2, "0") +
    String(today.getDate()).padStart(2, "0");
  const uniqueId = `copy-${datePrefix}-${timestamp}`;

  console.log(
    `å¤åˆ¶æ—¥æœŸåˆ—è¡¨: ${rightClickedDate} (${currentDisplayName}) -> ${copyName} (ID: ${uniqueId})`
  );

  // 1. å¤åˆ¶ä»»åŠ¡åˆ°æ–°çš„å”¯ä¸€æ ‡è¯†ç¬¦
  fetch(CONFIG.API_BASE + "/copy-date", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      source_date: rightClickedDate,
      target_date: uniqueId,
    }),
  })
    .then((response) => {
      if (response.ok) {
        return response.json();
      } else {
        throw new Error(`å¤åˆ¶ä»»åŠ¡å¤±è´¥: HTTP ${response.status}`);
      }
    })
    .then((result) => {
      if (result.error) {
        throw new Error(result.error);
      }
      console.log(`ä»»åŠ¡å¤åˆ¶æˆåŠŸ: ${result.message}`);
      return uniqueId;
    })
    .then((newId) => {
      // 2. ä¸ºæ–°IDè®¾ç½®åˆ«å - æ˜¾ç¤ºä¸ºåŸå§‹åç§°åŠ ä¸Š-copy
      return fetch(CONFIG.API_BASE.replace("/todos", "/date-aliases"), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          date: newId,
          alias: copyName,
        }),
      })
        .then((response) => {
          if (response.ok) {
            return response.json();
          } else {
            throw new Error(`è®¾ç½®åˆ«åå¤±è´¥: HTTP ${response.status}`);
          }
        })
        .then((result) => {
          if (result.error) {
            throw new Error(result.error);
          }
          console.log(`åˆ«åè®¾ç½®æˆåŠŸ: ${copyName}`);
          return newId;
        });
    })
    .then((newId) => {
      // 3. åˆ·æ–°æ—¥æœŸåˆ—è¡¨æ˜¾ç¤ºæ–°çš„å‰¯æœ¬
      generateDateList();

      // 4. æ˜¾ç¤ºæˆåŠŸæç¤º
      showNotification(
        `å·²å¤åˆ¶ "${currentDisplayName}" ä¸º "${copyName}"`,
        "success",
        "å¤åˆ¶æˆåŠŸ"
      );

      // 5. åˆ‡æ¢åˆ°æ–°åˆ›å»ºçš„å‰¯æœ¬
      setTimeout(() => {
        switchDate(newId);
        console.log(`å¤åˆ¶å®Œæˆï¼Œå·²åˆ‡æ¢åˆ°æ–°ID: ${newId}`);
      }, 500); // å»¶è¿Ÿä¸€ç‚¹ç¡®ä¿åˆ—è¡¨å·²åˆ·æ–°
    })
    .catch((error) => {
      showNotification("å¤åˆ¶å¤±è´¥: " + error.message, "error", "å¤åˆ¶å¤±è´¥");
      console.error("å¤åˆ¶ä»»åŠ¡å¤±è´¥:", error);
    });

  document.getElementById("context-menu").style.display = "none";
}

// é‡å‘½åæ—¥æœŸåˆ—è¡¨åŠŸèƒ½ - è®¾ç½®æ—¥æœŸåˆ«å
function renameDateList() {
  if (!rightClickedDate) return;

  // è·å–å½“å‰æ˜¾ç¤ºçš„åç§°ï¼ˆå¯èƒ½æ˜¯åˆ«åï¼‰
  const currentDisplayName = document.querySelector(
    `[data-date="${rightClickedDate}"] .date-name`
  ).textContent;
  const newName = prompt(`è¯·è¾“å…¥æ–°çš„åç§°:`, currentDisplayName);

  if (!newName || newName.trim() === "") {
    document.getElementById("context-menu").style.display = "none";
    return;
  }

  console.log(`é‡å‘½åæ—¥æœŸ ${rightClickedDate} ä¸º: ${newName.trim()}`);

  // è°ƒç”¨APIè®¾ç½®æ—¥æœŸåˆ«å
  fetch(CONFIG.API_BASE.replace("/todos", "/date-aliases"), {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      date: rightClickedDate,
      alias: newName.trim(),
    }),
  })
    .then((response) => {
      if (response.ok) {
        return response.json();
      } else {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
    })
    .then((result) => {
      if (result.error) {
        showNotification("é‡å‘½åå¤±è´¥: " + result.error, "error", "é‡å‘½åå¤±è´¥");
      } else {
        console.log("é‡å‘½åæˆåŠŸ:", result.message);
        // é‡æ–°ç”Ÿæˆæ—¥æœŸåˆ—è¡¨ä»¥æ˜¾ç¤ºæ–°åˆ«å
        generateDateList();
        // æ˜¾ç¤ºæˆåŠŸæç¤º
        showNotification(
          `å·²é‡å‘½åä¸º "${newName.trim()}"`,
          "success",
          "é‡å‘½åæˆåŠŸ"
        );
      }
    })
    .catch((error) => {
      showNotification("é‡å‘½åå¤±è´¥: " + error.message, "error", "é‡å‘½åå¤±è´¥");
      console.error("è®¾ç½®æ—¥æœŸåˆ«åå¤±è´¥:", error);
    });

  document.getElementById("context-menu").style.display = "none";
}

// åˆ é™¤æ—¥æœŸåˆ—è¡¨åŠŸèƒ½
function deleteDateList() {
  if (!rightClickedDate) return;

  const displayName = document.querySelector(
    `[data-date="${rightClickedDate}"] .date-name`
  ).textContent;

  if (!confirm(`ç¡®å®šè¦åˆ é™¤ "${displayName}" çš„æ‰€æœ‰ä»»åŠ¡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼`)) {
    document.getElementById("context-menu").style.display = "none";
    return;
  }

  // ä½¿ç”¨æ–°çš„æ‰¹é‡åˆ é™¤API
  fetch(CONFIG.API_BASE + "/date/" + rightClickedDate, { method: "DELETE" })
    .then((response) => {
      console.log("åˆ é™¤å“åº”çŠ¶æ€:", response.status, response.statusText);
      console.log("å“åº”æ˜¯å¦OK:", response.ok);

      if (response.ok) {
        return response.json();
      } else {
        // è®°å½•è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
        return response.text().then((text) => {
          console.error("åˆ é™¤å¤±è´¥å“åº”å†…å®¹:", text);
          throw new Error(
            `åˆ é™¤å¤±è´¥: ${response.status} ${response.statusText} - ${text}`
          );
        });
      }
    })
    .then((result) => {
      console.log("åˆ é™¤æˆåŠŸå“åº”:", result);

      // åˆ é™¤æˆåŠŸåï¼Œåˆ·æ–°æ—¥æœŸåˆ—è¡¨ï¼ˆè®©è¢«åˆ é™¤çš„æ—¥æœŸä»å·¦ä¾§æ¶ˆå¤±ï¼‰
      generateDateList();

      // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ—¥æœŸï¼Œåˆ‡æ¢åˆ°ä»Šå¤©
      if (rightClickedDate === currentDate) {
        const today = new Date().toISOString().split("T")[0];
        switchDate(today);
      }

      // æ˜¾ç¤ºåˆ é™¤æˆåŠŸæç¤º
      showNotification(
        `å·²åˆ é™¤ "${displayName}" çš„æ‰€æœ‰ä»»åŠ¡`,
        "success",
        "åˆ é™¤æˆåŠŸ"
      );
      console.log("åˆ é™¤æˆåŠŸ:", result.message);
    })
    .catch((error) => {
      console.error("åˆ é™¤ä»»åŠ¡å¤±è´¥è¯¦ç»†ä¿¡æ¯:", error);
      showNotification("åˆ é™¤å¤±è´¥: " + error.message, "error", "åˆ é™¤å¤±è´¥");
    });

  document.getElementById("context-menu").style.display = "none";
}
// ç½®é¡¶/å–æ¶ˆç½®é¡¶æ—¥æœŸåˆ—è¡¨åŠŸèƒ½
function togglePinDateList() {
  if (!rightClickedDate) return;

  const displayName = document.querySelector(
    `[data-date="${rightClickedDate}"] .date-name`
  ).textContent;

  if (pinnedDates.has(rightClickedDate)) {
    // å–æ¶ˆç½®é¡¶
    pinnedDates.delete(rightClickedDate);
    showNotification(`å·²å–æ¶ˆç½®é¡¶ "${displayName}"`, "success", "å–æ¶ˆç½®é¡¶");
    console.log(`å–æ¶ˆç½®é¡¶æ—¥æœŸ: ${rightClickedDate}`);
  } else {
    // ç½®é¡¶
    pinnedDates.add(rightClickedDate);
    showNotification(`å·²ç½®é¡¶ "${displayName}"`, "success", "ç½®é¡¶æˆåŠŸ");
    console.log(`ç½®é¡¶æ—¥æœŸ: ${rightClickedDate}`);
  }

  // ä¿å­˜ç½®é¡¶çŠ¶æ€åˆ°æœ¬åœ°å­˜å‚¨
  savePinnedDates();

  // é‡æ–°ç”Ÿæˆæ—¥æœŸåˆ—è¡¨ä»¥åæ˜ ç½®é¡¶çŠ¶æ€
  generateDateList();

  document.getElementById("context-menu").style.display = "none";
}

// ä¿å­˜ç½®é¡¶çŠ¶æ€åˆ°æœ¬åœ°å­˜å‚¨
function savePinnedDates() {
  try {
    localStorage.setItem("pinnedDates", JSON.stringify([...pinnedDates]));
  } catch (error) {
    console.error("ä¿å­˜ç½®é¡¶çŠ¶æ€å¤±è´¥:", error);
  }
}

// ä»æœ¬åœ°å­˜å‚¨åŠ è½½ç½®é¡¶çŠ¶æ€
function loadPinnedDates() {
  try {
    const saved = localStorage.getItem("pinnedDates");
    if (saved) {
      const dates = JSON.parse(saved);
      pinnedDates = new Set(dates);
    }
  } catch (error) {
    console.error("åŠ è½½ç½®é¡¶çŠ¶æ€å¤±è´¥:", error);
    pinnedDates = new Set();
  }
}


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\js\loading.js
å†…å®¹:
/**
 * åŠ è½½çŠ¶æ€ç®¡ç†
 */

class LoadingManager {
  constructor() {
    this.loadingCount = 0;
    this.createLoadingElement();
  }

  createLoadingElement() {
    // åˆ›å»ºå…¨å±€åŠ è½½æŒ‡ç¤ºå™¨
    const loadingDiv = document.createElement("div");
    loadingDiv.id = "global-loading";
    loadingDiv.className = "loading-overlay";
    loadingDiv.innerHTML = `
      <div class="loading-spinner">
        <div class="spinner-border text-primary" role="status">
          <span class="visually-hidden">åŠ è½½ä¸­...</span>
        </div>
        <div class="loading-text">åŠ è½½ä¸­...</div>
      </div>
    `;
    loadingDiv.style.display = "none";
    document.body.appendChild(loadingDiv);
  }

  show(message = "åŠ è½½ä¸­...") {
    this.loadingCount++;
    const loadingElement = document.getElementById("global-loading");
    const textElement = loadingElement.querySelector(".loading-text");
    if (textElement) {
      textElement.textContent = message;
    }
    loadingElement.style.display = "flex";
  }

  hide() {
    this.loadingCount = Math.max(0, this.loadingCount - 1);
    if (this.loadingCount === 0) {
      const loadingElement = document.getElementById("global-loading");
      loadingElement.style.display = "none";
    }
  }

  // åŒ…è£…fetchè¯·æ±‚ï¼Œè‡ªåŠ¨æ˜¾ç¤º/éšè—åŠ è½½çŠ¶æ€
  async fetchWithLoading(url, options = {}, message = "åŠ è½½ä¸­...") {
    this.show(message);
    try {
      const response = await fetch(url, options);
      return response;
    } finally {
      this.hide();
    }
  }
}

// åˆ›å»ºå…¨å±€åŠ è½½ç®¡ç†å™¨å®ä¾‹
const loadingManager = new LoadingManager();

// æ•°æ®ç¼“å­˜ç®¡ç†
class CacheManager {
  constructor() {
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5åˆ†é’Ÿç¼“å­˜
  }

  set(key, data) {
    this.cache.set(key, {
      data: data,
      timestamp: Date.now(),
    });
  }

  get(key) {
    const cached = this.cache.get(key);
    if (!cached) return null;

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - cached.timestamp > this.cacheTimeout) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  clear() {
    this.cache.clear();
  }

  // æ¸…é™¤ç‰¹å®šå‰ç¼€çš„ç¼“å­˜
  clearByPrefix(prefix) {
    for (const key of this.cache.keys()) {
      if (key.startsWith(prefix)) {
        this.cache.delete(key);
      }
    }
  }
}

// åˆ›å»ºå…¨å±€ç¼“å­˜ç®¡ç†å™¨å®ä¾‹
const cacheManager = new CacheManager();


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\js\main.js
å†…å®¹:
/**
 * ä¸»åº”ç”¨åˆå§‹åŒ–å’Œäº‹ä»¶ç»‘å®š
 */

// è¡¨å•æäº¤äº‹ä»¶
document.getElementById("add-form").onsubmit = function (e) {
  e.preventDefault();
  const content = document.getElementById("new-todo").value.trim();
  if (!content) return;
  fetch(CONFIG.API_BASE, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ content, date: currentDate }),
  }).then(() => {
    document.getElementById("new-todo").value = "";
    fetchTodos();
  });
};

// ç‚¹å‡»å…¶ä»–åœ°æ–¹éšè—å³é”®èœå•
document.addEventListener("click", function () {
  document.getElementById("context-menu").style.display = "none";
});

// æ”¯æŒå›è½¦é”®æœç´¢
document
  .getElementById("search-input")
  .addEventListener("keydown", function (e) {
    if (e.key === "Enter") {
      e.preventDefault();
      searchTodos();
    }
  });

// åˆå§‹åŒ–æ–°ä»»åŠ¡è¾“å…¥æ¡†
const newTodoTextarea = document.getElementById("new-todo");
setupTextarea(newTodoTextarea);

// åº”ç”¨åˆå§‹åŒ–
function initApp() {
  // åŠ è½½ç½®é¡¶çŠ¶æ€
  loadPinnedDates();

  // ç”Ÿæˆæ—¥æœŸåˆ—è¡¨
  generateDateList();

  // è®¾ç½®åˆå§‹æ ‡é¢˜
  const title = document.getElementById("current-date-title");
  title.textContent = `${formatDateForDisplay(currentDate)} Todo`;

  // åŠ è½½å½“å‰æ—¥æœŸçš„todos
  fetchTodos();
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener("DOMContentLoaded", function () {
  initApp();
});


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\js\search.js
å†…å®¹:
/**
 * æœç´¢ç›¸å…³åŠŸèƒ½
 */

function searchTodos() {
  const searchTerm = document.getElementById("search-input").value.trim();
  if (!searchTerm) {
    alert("è¯·è¾“å…¥æœç´¢å…³é”®è¯");
    return;
  }

  isSearchMode = true;
  document.getElementById("clear-search-btn").style.display = "inline-block";

  // è·å–æ‰€æœ‰æ—¥æœŸçš„todosè¿›è¡Œæœç´¢
  fetchAllTodos().then(() => {
    const filteredTodos = allTodos.filter((todo) =>
      todo.content.toLowerCase().includes(searchTerm.toLowerCase())
    );

    displaySearchResults(filteredTodos, searchTerm);
  });
}

function clearSearch() {
  isSearchMode = false;
  document.getElementById("search-input").value = "";
  document.getElementById("clear-search-btn").style.display = "none";

  // æ¢å¤å½“å‰æ—¥æœŸçš„æ˜¾ç¤º
  const title = document.getElementById("current-date-title");
  title.textContent = `${formatDateForDisplay(currentDate)} Todo`;

  fetchTodos();
}

function fetchAllTodos() {
  // è·å–æ‰€æœ‰æ—¥æœŸçš„todos
  return fetch(CONFIG.API_BASE + "/counts")
    .then((r) => r.json())
    .then((counts) => {
      const promises = Object.keys(counts).map((date) =>
        fetch(CONFIG.API_BASE + "?date=" + date).then((r) => r.json())
      );

      return Promise.all(promises).then((results) => {
        allTodos = results.flat();
      });
    });
}

function displaySearchResults(filteredTodos, searchTerm) {
  const list = document.getElementById("todo-list");
  const title = document.getElementById("current-date-title");

  title.textContent = `æœç´¢ç»“æœ: "${searchTerm}" (${filteredTodos.length}æ¡)`;

  list.innerHTML = "";

  if (filteredTodos.length === 0) {
    list.innerHTML =
      '<li class="list-group-item text-center text-muted">æœªæ‰¾åˆ°åŒ¹é…çš„ä»»åŠ¡</li>';
    return;
  }

  filteredTodos.forEach((todo) => {
    const li = document.createElement("li");
    li.className = "list-group-item";
    let contentClass = "flex-grow-1 todo-content";
    if (todo.completed) contentClass += " todo-completed";

    // é«˜äº®æœç´¢å…³é”®è¯
    const highlightedContent = todo.content.replace(
      new RegExp(searchTerm, "gi"),
      `<mark>${searchTerm}</mark>`
    );

    li.innerHTML = `
      <span class="${contentClass}" ondblclick="toggleComplete(${
      todo.id
    })" id="content-${todo.id}">${highlightedContent}</span>
      <span class="todo-dates">${formatDateForDisplay(todo.date)} | ${
      todo.completed
        ? "å®Œæˆ: " + formatDate(todo.completed_at)
        : "åˆ›å»º: " + formatDate(todo.created_at)
    }</span>
      <div class="todo-actions">
          <button class="btn btn-sm btn-outline-secondary" onclick="copyTodoContent(${
            todo.id
          }, this)">å¤åˆ¶</button>
          <button class="btn btn-sm btn-outline-secondary" onclick="editTodo(${
            todo.id
          })">ä¿®æ”¹</button>
          <button class="btn btn-sm btn-outline-danger" onclick="deleteTodo(${
            todo.id
          })">åˆ é™¤</button>
      </div>
    `;
    li.style.display = "flex";
    li.style.alignItems = "flex-start";
    list.appendChild(li);
  });
}


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\js\sidebar.js
å†…å®¹:
/**
 * ä¾§è¾¹æ ç›¸å…³åŠŸèƒ½
 */

function generateDateList() {
  const dateList = document.getElementById("date-list");
  dateList.innerHTML = "";

  // è·å–æ‰€æœ‰æœ‰æ•°æ®çš„æ—¥æœŸï¼ˆåŒ…æ‹¬ç”¨æˆ·åˆ›å»ºçš„å‰¯æœ¬ï¼‰
  fetch(CONFIG.API_BASE + "/counts")
    .then((r) => r.json())
    .then((counts) => {
      // è·å–æ‰€æœ‰æœ‰æ•°æ®çš„æ—¥æœŸ
      const allDates = Object.keys(counts);

      // åªæ·»åŠ ä»Šå¤©çš„æ—¥æœŸï¼ˆå¦‚æœä¸å­˜åœ¨çš„è¯ï¼‰ï¼Œå…¶ä»–æ—¥æœŸåªæœ‰åœ¨æœ‰æ•°æ®æ—¶æ‰æ˜¾ç¤º
      const today = new Date().toISOString().split("T")[0];
      if (!allDates.includes(today)) {
        allDates.push(today);
      }

      // åˆ†ç¦»ç½®é¡¶å’Œéç½®é¡¶çš„æ—¥æœŸ
      const pinnedDatesList = allDates.filter((date) => pinnedDates.has(date));
      const unpinnedDatesList = allDates.filter(
        (date) => !pinnedDates.has(date)
      );

      // ç½®é¡¶æ—¥æœŸæŒ‰æ—¶é—´æ’åºï¼ˆæœ€æ–°åœ¨å‰ï¼‰ï¼Œéç½®é¡¶æ—¥æœŸä¹ŸæŒ‰æ—¶é—´æ’åº
      pinnedDatesList.sort((a, b) => new Date(b) - new Date(a));
      unpinnedDatesList.sort((a, b) => new Date(b) - new Date(a));

      // åˆå¹¶åˆ—è¡¨ï¼šç½®é¡¶çš„åœ¨å‰é¢
      const sortedDates = [...pinnedDatesList, ...unpinnedDatesList];

      // è·å–æ—¥æœŸåˆ«å
      return fetch(CONFIG.API_BASE.replace("/todos", "/date-aliases"))
        .then((r) => r.json())
        .then((aliases) => {
          sortedDates.forEach((dateStr) => {
            const li = document.createElement("li");
            li.className = "date-item";
            if (dateStr === currentDate) {
              li.classList.add("active");
            }

            // å¦‚æœæ˜¯ç½®é¡¶çš„æ—¥æœŸï¼Œæ·»åŠ ç½®é¡¶æ ·å¼
            if (pinnedDates.has(dateStr)) {
              li.classList.add("pinned");
            }

            // ä½¿ç”¨åˆ«åï¼ˆå¦‚æœå­˜åœ¨ï¼‰æˆ–é»˜è®¤çš„æ—¥æœŸæ˜¾ç¤º
            const displayName =
              aliases[dateStr] || formatDateForDisplay(dateStr);

            // æ ¹æ®æ˜¯å¦ç½®é¡¶ç”Ÿæˆä¸åŒçš„HTMLç»“æ„
            if (pinnedDates.has(dateStr)) {
              li.innerHTML = `
                <span class="date-name">${displayName}</span>
                <span class="pin-icon">ğŸ“Œ</span>
              `;
            } else {
              li.innerHTML = `
                <span class="date-name">${displayName}</span>
              `;
            }

            // æ·»åŠ æ•°æ®å±æ€§ä»¥ä¾¿å‡†ç¡®è¯†åˆ«
            li.dataset.date = dateStr;

            li.onclick = () => switchDate(dateStr);

            // æ·»åŠ å³é”®èœå•äº‹ä»¶
            addContextMenuToDateItem(li, dateStr);

            dateList.appendChild(li);
          });

          updateTodoCounts();
        });
    })
    .catch((error) => {
      console.error("è·å–æ—¥æœŸåˆ—è¡¨å¤±è´¥:", error);
      // å¦‚æœè·å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤çš„7å¤©æ˜¾ç¤º
      const dates = [];
      const baseDate = new Date();
      for (let i = 0; i >= -7; i--) {
        const date = new Date(baseDate);
        date.setDate(baseDate.getDate() + i);
        dates.push(date.toISOString().split("T")[0]);
      }

      dates.forEach((dateStr) => {
        const li = document.createElement("li");
        li.className = "date-item";
        if (dateStr === currentDate) {
          li.classList.add("active");
        }

        li.innerHTML = `
          <span class="date-name">${formatDateForDisplay(dateStr)}</span>
        `;

        li.dataset.date = dateStr;
        li.onclick = () => switchDate(dateStr);
        addContextMenuToDateItem(li, dateStr);
        dateList.appendChild(li);
      });

      updateTodoCounts();
    });
}

function switchDate(dateStr) {
  currentDate = dateStr;

  // æ›´æ–°ä¾§è¾¹æ é€‰ä¸­çŠ¶æ€
  document.querySelectorAll(".date-item").forEach((item) => {
    item.classList.remove("active");
  });

  // æ‰¾åˆ°å¯¹åº”çš„æ—¥æœŸé¡¹å¹¶è®¾ç½®ä¸ºæ´»è·ƒçŠ¶æ€
  document.querySelectorAll(".date-item").forEach((item) => {
    if (item.dataset.date === dateStr) {
      item.classList.add("active");
    }
  });

  // è·å–åˆ«åå¹¶æ›´æ–°æ ‡é¢˜
  fetch(CONFIG.API_BASE.replace("/todos", "/date-aliases"))
    .then((r) => r.json())
    .then((aliases) => {
      const title = document.getElementById("current-date-title");
      // ä½¿ç”¨åˆ«åï¼ˆå¦‚æœå­˜åœ¨ï¼‰æˆ–é»˜è®¤çš„æ—¥æœŸæ˜¾ç¤º
      const displayName = aliases[dateStr] || formatDateForDisplay(dateStr);
      title.textContent = `${displayName} Todo`;
    })
    .catch((error) => {
      console.error("è·å–æ—¥æœŸåˆ«åå¤±è´¥:", error);
      // å¦‚æœè·å–åˆ«åå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ˜¾ç¤º
      const title = document.getElementById("current-date-title");
      title.textContent = `${formatDateForDisplay(dateStr)} Todo`;
    });

  // é‡æ–°åŠ è½½è¯¥æ—¥æœŸçš„todos
  fetchTodos();
}

function updateTodoCounts() {
  // ä¸å†éœ€è¦æ˜¾ç¤ºè®¡æ•°ï¼Œä¿ç•™å‡½æ•°ä»¥å…å…¶ä»–åœ°æ–¹è°ƒç”¨å‡ºé”™
}

function toggleSidebar() {
  const sidebar = document.getElementById("sidebar");
  const icon = document.getElementById("collapse-icon");
  const mainContent = document.querySelector(".main-content");

  sidebar.classList.toggle("collapsed");

  if (sidebar.classList.contains("collapsed")) {
    icon.textContent = "â–¶";
    mainContent.style.marginLeft = "0";
  } else {
    icon.textContent = "â—€";
    mainContent.style.marginLeft = "0";
  }
}


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\js\todos.js
å†…å®¹:
/**
 * Todo ç›¸å…³åŠŸèƒ½
 */

function fetchTodos() {
  // æŒ‰æ—¥æœŸç­›é€‰todos
  fetch(CONFIG.API_BASE + "?date=" + currentDate)
    .then((r) => r.json())
    .then((data) => {
      const list = document.getElementById("todo-list");
      list.innerHTML = "";
      data.reverse(); // æ–°å¢çš„ todo æ˜¾ç¤ºåœ¨æœ€ä¸Šé¢
      data.forEach((todo, idx) => {
        const li = document.createElement("li");
        li.className = "list-group-item";
        let contentClass = "flex-grow-1 todo-content";
        if (todo.completed) contentClass += " todo-completed";
        li.innerHTML = `
          <span class="${contentClass}" ondblclick="toggleComplete(${
          todo.id
        })" id="content-${todo.id}">${todo.content}</span>
          <span class="todo-dates">${
            todo.completed
              ? "å®Œæˆ: " + formatDate(todo.completed_at)
              : "åˆ›å»º: " + formatDate(todo.created_at)
          }</span>
          <div class="todo-actions">
              <button class="btn btn-sm btn-outline-secondary" onclick="copyTodoContent(${
                todo.id
              }, this)">å¤åˆ¶</button>
              <button class="btn btn-sm btn-outline-secondary" onclick="editTodo(${
                todo.id
              })">ä¿®æ”¹</button>
              <button class="btn btn-sm btn-outline-danger" onclick="deleteTodo(${
                todo.id
              })">åˆ é™¤</button>
          </div>
        `;
        li.style.display = "flex";
        li.style.alignItems = "flex-start";
        list.appendChild(li);
      });

      // æ›´æ–°è®¡æ•°
      updateTodoCounts();
    });
}

function toggleComplete(id) {
  fetch(CONFIG.API_BASE + "/" + id + "?date=" + currentDate, { method: "GET" })
    .then((r) => r.json())
    .then((todo) => {
      const completed = !todo.completed;
      fetch(CONFIG.API_BASE + "/" + id, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          completed,
          date: currentDate,
        }),
      }).then(fetchTodos);
    });
}

function editTodo(id) {
  const span = document.getElementById("content-" + id);
  const old = span.textContent;
  const textarea = document.createElement("textarea");
  textarea.value = old;
  textarea.className = "form-control d-inline";
  textarea.style.marginRight = "8px";
  textarea.style.flex = "1 1 0%";
  textarea.style.marginLeft = "0";
  textarea.style.resize = "vertical";
  textarea.style.minHeight = "38px";
  textarea.rows = 1;

  span.replaceWith(textarea);

  // è®¾ç½®textareaåŠŸèƒ½
  setupTextarea(textarea);
  textarea.focus();

  // é€‰ä¸­æ‰€æœ‰æ–‡æœ¬
  textarea.select();

  textarea.onblur = function () {
    fetch(CONFIG.API_BASE + "/" + id, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        content: textarea.value,
        date: currentDate,
      }),
    }).then(fetchTodos);
  };

  // é‡å†™é”®ç›˜äº‹ä»¶å¤„ç†ï¼Œæ”¯æŒShift+Enteræ¢è¡Œï¼ŒEnterä¿å­˜
  textarea.onkeydown = function (e) {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      textarea.blur();
    }
    if (e.key === "Escape") {
      e.preventDefault();
      fetchTodos(); // å–æ¶ˆç¼–è¾‘ï¼Œé‡æ–°åŠ è½½
    }
  };
}

function deleteTodo(id) {
  fetch(CONFIG.API_BASE + "/" + id + "?date=" + currentDate, {
    method: "DELETE",
  }).then(fetchTodos);
}

function copyTodo(id) {
  fetch(CONFIG.API_BASE + "/" + id + "/copy?date=" + currentDate, {
    method: "POST",
  }).then(fetchTodos);
}

function moveTodo(id, newOrder) {
  fetch(CONFIG.API_BASE)
    .then((r) => r.json())
    .then((data) => {
      if (newOrder < 0 || newOrder >= data.length) return;
      fetch(CONFIG.API_BASE + "/move", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id: id, order: newOrder }),
      }).then(fetchTodos);
    });
}

// å¤åˆ¶todoå†…å®¹åˆ°å‰ªè´´æ¿
function copyTodoContent(id, buttonElement) {
  const contentElement = document.getElementById("content-" + id);
  const todoContent = contentElement.textContent;

  // ä½¿ç”¨ç°ä»£å‰ªè´´æ¿API
  if (navigator.clipboard && window.isSecureContext) {
    navigator.clipboard
      .writeText(todoContent)
      .then(() => {
        showCopySuccess(buttonElement);
      })
      .catch(() => {
        // å¦‚æœç°ä»£APIå¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•
        fallbackCopyTextToClipboard(todoContent, buttonElement);
      });
  } else {
    // ä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•
    fallbackCopyTextToClipboard(todoContent, buttonElement);
  }
}

function exportCurrentDate() {
  // åˆ›å»ºéšè—çš„ä¸‹è½½é“¾æ¥ï¼Œé¿å…é¡µé¢é—ªçƒ
  const link = document.createElement("a");
  link.href = CONFIG.API_BASE + "/export/" + currentDate;
  link.download = `${formatDateForDisplay(currentDate).replace(
    /\s+/g,
    ""
  )}-todo.md`;
  link.style.display = "none";

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  // æ˜¾ç¤ºä¸‹è½½æˆåŠŸæç¤º
  showNotification(
    `${formatDateForDisplay(currentDate)} çš„ä»»åŠ¡å·²å¯¼å‡º`,
    "success",
    "å¯¼å‡ºæˆåŠŸ"
  );
}


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\static\js\utils.js
å†…å®¹:
/**
 * å·¥å…·å‡½æ•°
 */

function formatDate(dt) {
  if (!dt) return "";
  const d = new Date(dt);
  if (isNaN(d)) return "";
  // ç›´æ¥ä½¿ç”¨æœ¬åœ°æ—¶é—´æ ¼å¼åŒ–
  return d.toLocaleTimeString("zh-CN", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });
}

function formatDateForDisplay(dateStr) {
  // é¿å…æ—¶åŒºé—®é¢˜ï¼Œç›´æ¥è§£ææ—¥æœŸå­—ç¬¦ä¸²
  const [year, month, day] = dateStr.split("-");
  const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));

  // å§‹ç»ˆæ˜¾ç¤ºå…·ä½“çš„æœˆæ—¥ï¼Œä¸ä½¿ç”¨ç›¸å¯¹æ—¶é—´
  return date.toLocaleDateString("zh-CN", {
    month: "long",
    day: "numeric",
  });
}

// å¤„ç†textareaçš„è‡ªåŠ¨è°ƒæ•´é«˜åº¦å’ŒShift+Enteræ¢è¡Œ
function setupTextarea(textarea) {
  // è‡ªåŠ¨è°ƒæ•´é«˜åº¦
  function adjustHeight() {
    textarea.style.height = "auto";
    textarea.style.height = Math.max(38, textarea.scrollHeight) + "px";
  }

  textarea.addEventListener("input", adjustHeight);

  // å¤„ç†é”®ç›˜äº‹ä»¶
  textarea.addEventListener("keydown", function (e) {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      if (textarea.form) {
        textarea.form.dispatchEvent(new Event("submit"));
      }
    }
  });

  // åˆå§‹è°ƒæ•´
  adjustHeight();
}

// ä¼ ç»Ÿçš„å¤åˆ¶æ–¹æ³•ï¼ˆå…¼å®¹æ€§æ›´å¥½ï¼‰
function fallbackCopyTextToClipboard(text, buttonElement) {
  const textArea = document.createElement("textarea");
  textArea.value = text;
  textArea.style.position = "fixed";
  textArea.style.left = "-999999px";
  textArea.style.top = "-999999px";
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();

  try {
    const successful = document.execCommand("copy");
    if (successful) {
      showCopySuccess(buttonElement);
    } else {
      console.error("å¤åˆ¶å¤±è´¥");
    }
  } catch (err) {
    console.error("å¤åˆ¶å¤±è´¥:", err);
  }

  document.body.removeChild(textArea);
}

// æ˜¾ç¤ºå¤åˆ¶æˆåŠŸçŠ¶æ€
function showCopySuccess(buttonElement) {
  const originalText = buttonElement.textContent;
  buttonElement.textContent = "å·²å¤åˆ¶";
  buttonElement.classList.remove("btn-outline-secondary");
  buttonElement.classList.add("btn-success");

  // 2ç§’åæ¢å¤åŸçŠ¶
  setTimeout(() => {
    buttonElement.textContent = originalText;
    buttonElement.classList.remove("btn-success");
    buttonElement.classList.add("btn-outline-secondary");
  }, 2000);
}

// æ˜¾ç¤ºé€šçŸ¥æ¶ˆæ¯
function showNotification(message, type = "success", title = "æç¤º") {
  const toast = document.getElementById("notification-toast");
  const toastTitle = document.getElementById("toast-title");
  const toastMessage = document.getElementById("toast-message");

  // è®¾ç½®æ¶ˆæ¯å†…å®¹
  toastTitle.textContent = title;
  toastMessage.textContent = message;

  // æ ¹æ®ç±»å‹è®¾ç½®æ ·å¼
  toast.className = "toast";
  if (type === "success") {
    toast.classList.add("bg-success", "text-white");
  } else if (type === "error") {
    toast.classList.add("bg-danger", "text-white");
  } else if (type === "warning") {
    toast.classList.add("bg-warning", "text-dark");
  } else {
    toast.classList.add("bg-info", "text-white");
  }

  // æ˜¾ç¤ºé€šçŸ¥
  const bsToast = new bootstrap.Toast(toast, {
    autohide: true,
    delay: 3000,
  });
  bsToast.show();
}


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\templates\favicon.ico
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\templates\index.html
å†…å®¹:
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />

    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flask Todo List</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/static/css/style.css" />
  </head>
  <body>
    <!-- å·¦ä¾§èœå•é¢æ¿ -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h3>Todo æ–‡ä»¶</h3>
        <button class="collapse-btn" onclick="toggleSidebar()">
          <span id="collapse-icon">â—€</span>
        </button>
      </div>
      <ul class="date-list" id="date-list">
        <!-- æ—¥æœŸåˆ—è¡¨å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
      </ul>
    </div>

    <!-- ä¸»å†…å®¹åŒºåŸŸ -->
    <div class="main-content">
      <div class="container">
        <div class="d-flex justify-content-between align-items-center mb-4">
          <h1 class="mb-0" id="current-date-title">åŠ è½½ä¸­...</h1>
          <div class="d-flex align-items-center gap-3">
            <button
              class="btn btn-outline-secondary"
              onclick="exportCurrentDate()"
              style="
                padding: 6px 8px;
                font-size: 1.15rem;
                min-width: 54px;
                font-weight: normal;
                line-height: 1.4;
              "
            >
              å¯¼å‡º
            </button>
            <div class="d-flex align-items-center gap-2">
              <input
                type="text"
                class="form-control"
                id="search-input"
                placeholder="æœç´¢ä»»åŠ¡..."
                style="
                  width: 300px;
                  padding: 6px 8px;
                  font-size: 1.15rem;
                  font-weight: normal;
                  line-height: 1.4;
                "
              />
              <button
                class="btn btn-outline-primary"
                onclick="searchTodos()"
                style="
                  padding: 6px 8px;
                  font-size: 1.15rem;
                  min-width: 54px;
                  font-weight: normal;
                  line-height: 1.4;
                "
              >
                æœç´¢
              </button>
              <button
                class="btn btn-outline-secondary"
                onclick="clearSearch()"
                id="clear-search-btn"
                style="
                  display: none;
                  padding: 6px 8px;
                  font-size: 1.15rem;
                  min-width: 54px;
                  font-weight: normal;
                  line-height: 1.4;
                "
              >
                æ¸…é™¤
              </button>
            </div>
          </div>
        </div>
        <form id="add-form" class="d-flex gap-3 mb-3">
          <textarea
            class="form-control"
            id="new-todo"
            placeholder="æ·»åŠ æ–°ä»»åŠ¡ (Shift+Enteræ¢è¡Œï¼ŒEnteræäº¤)"
            autocomplete="off"
            required
            rows="2"
            style="
              resize: vertical;
              min-height: 76px;
              font-size: 1.2rem;
              padding: 16px 20px;
              flex: 1;
            "
          ></textarea>
          <button
            class="btn btn-primary"
            type="submit"
            style="
              min-width: 120px;
              font-size: 1.3rem;
              font-weight: bold;
              padding: 0;
              height: 76px;
              display: flex;
              align-items: center;
              justify-content: center;
            "
          >
            æ·»åŠ 
          </button>
        </form>
        <ul class="list-group" id="todo-list"></ul>
      </div>
    </div>

    <!-- å³é”®èœå• -->
    <div class="context-menu" id="context-menu">
      <div
        class="context-menu-item"
        onclick="togglePinDateList()"
        id="pin-menu-item"
      >
        ç½®é¡¶
      </div>
      <div class="context-menu-item" onclick="copyDateList()">å¤åˆ¶åˆ—è¡¨</div>
      <div class="context-menu-item" onclick="renameDateList()">é‡å‘½å</div>
      <div class="context-menu-item danger" onclick="deleteDateList()">
        åˆ é™¤åˆ—è¡¨
      </div>
    </div>

    <!-- æ¶ˆæ¯æç¤º -->
    <div
      class="toast-container position-fixed top-0 end-0 p-3"
      style="z-index: 1050"
    >
      <div
        id="notification-toast"
        class="toast"
        role="alert"
        aria-live="assertive"
        aria-atomic="true"
      >
        <div class="toast-header">
          <strong class="me-auto" id="toast-title">æç¤º</strong>
          <button
            type="button"
            class="btn-close"
            data-bs-dismiss="toast"
            aria-label="Close"
          ></button>
        </div>
        <div class="toast-body" id="toast-message">æ“ä½œå®Œæˆ</div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <!-- æŒ‰ä¾èµ–é¡ºåºåŠ è½½JavaScriptæ–‡ä»¶ -->
    <script src="/static/js/config.js"></script>
    <script src="/static/js/utils.js"></script>
    <script src="/static/js/todos.js"></script>
    <script src="/static/js/search.js"></script>
    <script src="/static/js/sidebar.js"></script>
    <script src="/static/js/context-menu.js"></script>
    <script src="/static/js/main.js"></script>
  </body>
</html>


å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\utils\api_response.py
å†…å®¹:
"""
ç»Ÿä¸€çš„APIå“åº”æ ¼å¼
"""
from flask import jsonify
from datetime import datetime
from typing import Any, Optional

class APIResponse:
    """ç»Ÿä¸€çš„APIå“åº”ç±»"""
    
    @staticmethod
    def success(data: Any = None, message: str = "æ“ä½œæˆåŠŸ", status_code: int = 200):
        """æˆåŠŸå“åº”"""
        response = {
            "success": True,
            "data": data,
            "message": message,
            "timestamp": datetime.utcnow().isoformat()
        }
        return jsonify(response), status_code
    
    @staticmethod
    def error(message: str, error_code: Optional[str] = None, status_code: int = 400, data: Any = None):
        """é”™è¯¯å“åº”"""
        response = {
            "success": False,
            "message": message,
            "error_code": error_code,
            "data": data,
            "timestamp": datetime.utcnow().isoformat()
        }
        return jsonify(response), status_code
    
    @staticmethod
    def not_found(message: str = "èµ„æºæœªæ‰¾åˆ°"):
        """404å“åº”"""
        return APIResponse.error(message, "NOT_FOUND", 404)
    
    @staticmethod
    def server_error(message: str = "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯"):
        """500å“åº”"""
        return APIResponse.error(message, "INTERNAL_ERROR", 500)
    
    @staticmethod
    def validation_error(message: str = "è¾“å…¥æ•°æ®æ— æ•ˆ"):
        """éªŒè¯é”™è¯¯å“åº”"""
        return APIResponse.error(message, "VALIDATION_ERROR", 400)

class TodoAppException(Exception):
    """è‡ªå®šä¹‰å¼‚å¸¸ç±»"""
    
    def __init__(self, message: str, error_code: Optional[str] = None, status_code: int = 400):
        self.message = message
        self.error_code = error_code
        self.status_code = status_code
        super().__init__(self.message)
    
    def to_response(self):
        """è½¬æ¢ä¸ºAPIå“åº”"""
        return APIResponse.error(self.message, self.error_code, self.status_code)

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\utils\validators.py
å†…å®¹:
"""
è¾“å…¥éªŒè¯å·¥å…·
"""
import re
from datetime import datetime
from functools import wraps
from flask import request
from utils.api_response import APIResponse, TodoAppException

def validate_json(*required_fields):
    """éªŒè¯JSONè¯·æ±‚æ•°æ®çš„è£…é¥°å™¨"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not request.is_json:
                return APIResponse.validation_error("è¯·æ±‚å¿…é¡»æ˜¯JSONæ ¼å¼")
            
            data = request.get_json()
            if not data:
                return APIResponse.validation_error("è¯·æ±‚æ•°æ®ä¸èƒ½ä¸ºç©º")
            
            # æ£€æŸ¥å¿…éœ€å­—æ®µ
            missing_fields = []
            for field in required_fields:
                if field not in data or not data[field]:
                    missing_fields.append(field)
            
            if missing_fields:
                return APIResponse.validation_error(f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {', '.join(missing_fields)}")
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def validate_date_format(date_str: str) -> bool:
    """éªŒè¯æ—¥æœŸæ ¼å¼ YYYY-MM-DD"""
    if not date_str:
        return False
    
    try:
        datetime.strptime(date_str, '%Y-%m-%d')
        return True
    except ValueError:
        return False

def validate_content(content: str) -> str:
    """éªŒè¯ä»»åŠ¡å†…å®¹"""
    if not content or not content.strip():
        raise TodoAppException("ä»»åŠ¡å†…å®¹ä¸èƒ½ä¸ºç©º", "EMPTY_CONTENT")
    
    content = content.strip()
    if len(content) > 500:
        raise TodoAppException("ä»»åŠ¡å†…å®¹ä¸èƒ½è¶…è¿‡500ä¸ªå­—ç¬¦", "CONTENT_TOO_LONG")
    
    # æ£€æŸ¥æ˜¯å¦åŒ…å«æ¶æ„è„šæœ¬
    if re.search(r'<script|javascript:|on\w+\s*=', content, re.IGNORECASE):
        raise TodoAppException("ä»»åŠ¡å†…å®¹åŒ…å«ä¸å…è®¸çš„å­—ç¬¦", "INVALID_CONTENT")
    
    return content

def validate_alias(alias: str) -> str:
    """éªŒè¯åˆ«å"""
    if not alias or not alias.strip():
        raise TodoAppException("åˆ«åä¸èƒ½ä¸ºç©º", "EMPTY_ALIAS")
    
    alias = alias.strip()
    if len(alias) > 100:
        raise TodoAppException("åˆ«åä¸èƒ½è¶…è¿‡100ä¸ªå­—ç¬¦", "ALIAS_TOO_LONG")
    
    # æ£€æŸ¥æ˜¯å¦åŒ…å«æ¶æ„è„šæœ¬
    if re.search(r'<script|javascript:|on\w+\s*=', alias, re.IGNORECASE):
        raise TodoAppException("åˆ«ååŒ…å«ä¸å…è®¸çš„å­—ç¬¦", "INVALID_ALIAS")
    
    return alias

def validate_date_param(f):
    """éªŒè¯æ—¥æœŸå‚æ•°çš„è£…é¥°å™¨"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        date = request.args.get('date')
        if date and not validate_date_format(date):
            return APIResponse.validation_error("æ—¥æœŸæ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ YYYY-MM-DD æ ¼å¼")
        return f(*args, **kwargs)
    return decorated_function

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\æ•ˆæœå›¾\a1.png
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]

å®Œæ•´çš„è·¯å¾„: C:\Users\Administrator\Work\flask_todo_app\æ•ˆæœå›¾\a2.png
å†…å®¹: [æ— æ³•ä½œä¸ºæ–‡æœ¬è¯»å–ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶]
